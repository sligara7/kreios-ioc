{
  "workflow_metadata": {
    "workflow_id": "03a-development_implementation",
    "name": "Development Implementation Workflow",
    "version": "3.7.0",
    "description": "Research, implement core functionality, and integrate APIs/security",
    "created_from": "03-development.json v1.0.0 - D-01, D-02, D-04 extracted",
    "last_updated": "2025-10-27",
    "purpose": "Implement service functionality (setup + coding + integration)",
    "context_reduction": "Reduced from 1,061 lines to ~450 lines (58% reduction)"
  },
  "prerequisites": {
    "required_workflows": [
      "00-setup",
      "01-systems_engineering",
      "02-artifacts_visualization"
    ],
    "required_files": [
      "specs/machine/service_arch/{service}/service_architecture_v*.json (all services)",
      "specs/machine/interfaces/{interface}_icd.json (all interfaces)",
      "specs/human/documentation/DEVELOPMENT_HANDOFF.md",
      "docs/ARCHITECTURE_CONTEXT_SUMMARY.md"
    ]
  },
  "workflow_steps": [
    {
      "step_id": "D-01",
      "name": "Initialization & Environment Bootstrap",
      "description": "Set up reproducible development environment for each service",
      "phase": "initialization",
      "step_file": "workflow_steps/development/D-01-InitBootstrap.json",
      "maps_from": "Dev-01: Initialization & Environment Bootstrap",
      "actions": [
        {
          "action_id": "D-01-A00",
          "description": "Research current development best practices and industry standards (OPTIONAL)",
          "when": "Before setting up development environment",
          "user_prompt": {
            "ask": "Would you like to research current best practices for development tooling before setting up the environment?",
            "options": [
              "Yes - Research current best practices (recommended for new tech stacks)",
              "No - Skip research and use known/default tooling"
            ],
            "default": "No",
            "note": "Research takes 5-10 minutes but helps ensure modern, industry-standard tooling choices"
          },
          "if_yes": {
            "research_areas": [
              {
                "category": "Dependency Management",
                "query_template": "{language} dependency management best practices 2025",
                "examples": [
                  "Python: poetry vs hatchling vs pdm vs pip-tools",
                  "JavaScript: npm vs yarn vs pnpm",
                  "Java: Maven vs Gradle",
                  "Go: go modules best practices"
                ],
                "output_key": "dependency_management_recommendation"
              },
              {
                "category": "Container Best Practices",
                "query_template": "{language} Dockerfile best practices 2025",
                "examples": [
                  "Multi-stage builds",
                  "Security scanning",
                  "Layer optimization",
                  "Base image selection"
                ],
                "output_key": "container_recommendations"
              },
              {
                "category": "CI/CD Tooling",
                "query_template": "{language} CI/CD pipeline best practices 2025",
                "examples": [
                  "GitHub Actions vs GitLab CI vs Jenkins",
                  "Automated testing in CI",
                  "Deployment strategies",
                  "Environment promotion"
                ],
                "output_key": "cicd_recommendations"
              },
              {
                "category": "Observability Frameworks",
                "query_template": "{language} observability and monitoring best practices 2025",
                "examples": [
                  "Logging frameworks (structured logging)",
                  "Metrics collection (Prometheus, StatsD)",
                  "Distributed tracing (OpenTelemetry)",
                  "Error tracking (Sentry, Rollbar)"
                ],
                "output_key": "observability_recommendations"
              },
              {
                "category": "Security Standards",
                "query_template": "{language} security best practices 2025",
                "examples": [
                  "Dependency vulnerability scanning",
                  "Secrets management",
                  "Code security linting",
                  "OWASP compliance"
                ],
                "output_key": "security_recommendations"
              },
              {
                "category": "Testing Frameworks",
                "query_template": "{language} testing frameworks best practices 2025",
                "examples": [
                  "Unit testing (pytest, Jest, JUnit)",
                  "Integration testing",
                  "Mocking libraries",
                  "Test coverage tools"
                ],
                "output_key": "testing_recommendations"
              },
              {
                "category": "Linting and Formatting",
                "query_template": "{language} code quality tools 2025",
                "examples": [
                  "Python: ruff vs black vs pylint",
                  "JavaScript: ESLint, Prettier",
                  "Type checking (mypy, TypeScript)",
                  "Pre-commit hooks"
                ],
                "output_key": "code_quality_recommendations"
              },
              {
                "category": "Build Systems",
                "query_template": "{language} build system best practices 2025",
                "examples": [
                  "Build automation",
                  "Artifact packaging",
                  "Version management",
                  "Release automation"
                ],
                "output_key": "build_recommendations"
              }
            ],
            "research_method": "quick",
            "research_depth": "Top 3-5 results per category, focus on 2024-2025 sources",
            "time_budget": "5-10 minutes total",
            "tools": [
              "WebSearch",
              "WebFetch"
            ],
            "output_file": "context/development_tooling_research_{date}.md",
            "output_format": {
              "structure": [
                "# Development Tooling Research",
                "Date: {timestamp}",
                "Language/Framework: {primary_language}",
                "",
                "## Research Summary",
                "For each research_area:",
                "  ### {category}",
                "  **Current Best Practice**: {recommendation}",
                "  **Reasoning**: {why_this_is_recommended}",
                "  **Sources**: [links]",
                "",
                "## Recommendations for This Project",
                "Based on research, recommended tooling stack:",
                "- Dependency Management: {tool} (rationale)",
                "- Testing: {framework} (rationale)",
                "- etc."
              ],
              "example_output": "See templates/development_research_output_template.md"
            }
          },
          "if_no": {
            "action": "Skip research, proceed with default tooling based on service_architecture.json deployment section"
          },
          "llm_agent_instructions": [
            "ASK the user via AskUserQuestion tool if they want to research current best practices",
            "If YES: Use WebSearch for each research area, focusing on 2024-2025 sources",
            "Spend no more than 1-2 minutes per research area (quick search, top results only)",
            "Synthesize findings into actionable recommendations",
            "Save research to context/development_tooling_research_{date}.md",
            "Use research findings to inform D-01-A04 (dependency management) decisions",
            "If NO: Skip directly to D-01-A01"
          ],
          "success_criteria": [
            "User question asked and answered",
            "If yes: Research completed and saved to context/ directory",
            "If no: Research skipped, noted in working_memory.json"
          ]
        },
        {
          "action_id": "D-01-A01",
          "description": "Select development languages and frameworks",
          "tool": "select_development_languages.py",
          "command_pattern": "python3 {reflow_root}/tools/select_development_languages.py {system_root}",
          "purpose": "Interactive selection of languages/frameworks for each service",
          "outputs": [
            "specs/machine/development_language_configuration.json"
          ]
        },
        {
          "action_id": "D-01-A02",
          "description": "Bootstrap development context for each service",
          "tool": "bootstrap_development_context.py",
          "command_pattern": "python3 {reflow_root}/tools/bootstrap_development_context.py {system_root} --service {service_name}",
          "purpose": "Create development tracking files for each service",
          "creates": [
            "context/dev_working_memory.json",
            "context/dev_progress_tracker.json",
            "context/dev_current_focus.md"
          ]
        },
        {
          "action_id": "D-01-A03",
          "description": "Create service directory structure",
          "pattern": "For each service, create services/{service_name}/{src,tests,config,docs}",
          "purpose": "Standard directory layout for each service"
        },
        {
          "action_id": "D-01-A04",
          "description": "Initialize dependency management",
          "note": "If D-01-A00 research was performed, use those recommendations. Otherwise, use defaults below.",
          "check_for_research": "context/development_tooling_research_*.md (if exists, read dependency_management_recommendation section)",
          "modern_best_practices": {
            "Python": {
              "recommended": "poetry or hatchling (modern tools with lock files and dependency resolution)",
              "traditional": "requirements.txt (simple but lacks lock file and dependency resolution)",
              "rationale": "Poetry/hatchling provide reproducible builds, better dependency resolution, and standardized packaging"
            },
            "JavaScript": {
              "recommended": "pnpm or yarn (fast, disk-efficient)",
              "traditional": "npm (standard, widely compatible)",
              "rationale": "pnpm saves disk space via content-addressable storage, yarn has better workspace support"
            },
            "Java": {
              "recommended": "Gradle with version catalogs",
              "traditional": "Maven",
              "rationale": "Gradle is faster, more flexible, better for multi-module projects"
            },
            "Go": {
              "recommended": "go modules (standard)",
              "rationale": "Built-in, official Go dependency management"
            }
          },
          "examples": [
            "Python: pyproject.toml with poetry/hatchling (modern) or requirements.txt (traditional)",
            "JavaScript/TypeScript: package.json with pnpm/yarn (recommended) or npm",
            "Java: build.gradle with version catalogs or pom.xml",
            "Go: go.mod and go.sum"
          ],
          "purpose": "Set up reproducible dependency management using modern tools when possible",
          "outputs": [
            "services/{service}/pyproject.toml (Python with poetry/hatchling)",
            "services/{service}/requirements.txt (Python traditional)",
            "services/{service}/package.json (JavaScript)",
            "services/{service}/pom.xml or build.gradle (Java)",
            "services/{service}/go.mod (Go)"
          ],
          "llm_agent_instructions": [
            "CHECK if context/development_tooling_research_*.md exists from D-01-A00",
            "If exists: READ the dependency_management_recommendation section and use those recommendations",
            "If not exists: Use modern_best_practices guidance above",
            "For Python specifically: PREFER poetry or hatchling over requirements.txt for new projects",
            "Create appropriate dependency files in services/{service}/ directory",
            "Document dependency management choice in dev_current_focus.md"
          ]
        },
        {
          "action_id": "D-01-A05",
          "description": "Create build_ready_index.json",
          "location": "services/build_ready_index.json",
          "purpose": "Track which services are ready for build/test",
          "includes": "List of services with build status"
        },
        {
          "action_id": "D-01-A06",
          "description": "Create lightweight service prototype to validate architecture assumptions (OPTIONAL)",
          "when": "After environment bootstrap (D-01), before domain model implementation (D-02)",
          "new_in_version": "v3.6.0 - Early Testing Integration",
          "user_prompt": {
            "ask": "Would you like to create a prototype to validate architecture assumptions before full implementation?",
            "options": [
              "Yes - Create prototype (recommended for complex deployments, unfamiliar tech stacks, high-risk services)",
              "No - Skip prototyping and proceed to full implementation"
            ],
            "default": "No"
          },
          "when_to_recommend_yes": [
            "Complex deployment (database permissions, message queues, external integrations)",
            "Unfamiliar technology stack (first time using framework/platform)",
            "Uncertain operational environment (cloud permissions, network policies)",
            "High-risk service (score >= 2.6 from SE-02-A10 risk_assessment.json)"
          ],
          "purpose": "Quickly validate architecture assumptions before investing in full implementation",
          "time_budget": "2-4 hours per service",
          "what_to_implement": [
            "Health endpoints (/health, /ready) - REAL",
            "One API endpoint per interface - STUB (return hardcoded JSON)",
            "Database connection - REAL (connect to actual database)",
            "One migration - REAL (create one table)",
            "Configuration loading - REAL (read environment variables)",
            "Logging - REAL (emit structured logs)",
            "Docker build - REAL (create working Dockerfile)"
          ],
          "what_NOT_to_implement": [
            "Business logic (stub with hardcoded responses)",
            "Complete data models (minimal schema, one table)",
            "Complete test suite (smoke test only)",
            "Full observability (basic logging sufficient)"
          ],
          "success_criteria": [
            "Prototype service starts successfully",
            "Health endpoint responds 200 OK",
            "Database connection established as service user",
            "Migration runs successfully",
            "One API endpoint responds (stub data OK)",
            "Docker build succeeds",
            "Smoke test passes"
          ],
          "benefit": "Catch architectural issues (permissions, deployment config, infrastructure) in 2-4 hours instead of discovering after full implementation"
        }
      ],
      "tools_used": [
        "select_development_languages.py",
        "bootstrap_development_context.py"
      ],
      "templates_used": [
        "development_language_configuration_template.json",
        "dev_working_memory_template.json",
        "dev_progress_tracker_template.json"
      ],
      "outputs": [
        "specs/machine/development_language_configuration.json",
        "context/dev_working_memory.json",
        "services/{service_name}/ (directory structure)",
        "services/build_ready_index.json"
      ],
      "gates": [],
      "next_step": "D-02"
    },
    {
      "step_id": "D-02",
      "name": "Core & Domain Model Realization",
      "description": "Transform architecture specifications into code foundations",
      "phase": "implementation",
      "step_file": "workflow_steps/development/D-02-CoreAndDomain.json",
      "maps_from": "Dev-02: Core & Domain Model Realization",
      "actions": [
        {
          "action_id": "D-02-A01",
          "description": "Implement domain models (greenfield) OR analyze existing implementation (meta-analysis/brownfield)",
          "conditional_execution": {
            "if_greenfield": {
              "description": "Implement domain models from architecture",
              "source": "data_models from service_architecture.json",
              "purpose": "Create core business entities and value objects",
              "pattern": "Domain-driven design principles"
            },
            "if_meta_analysis_or_brownfield": {
              "description": "Analyze existing implementation quality",
              "purpose": "Validate existing code against architecture, identify quality gaps",
              "actions": [
                "Read existing code (tools, services, components)",
                "Analyze code quality (complexity, maintainability, documentation)",
                "Compare implementation to architecture specifications",
                "Identify gaps, technical debt, security issues",
                "Document findings in analysis report"
              ],
              "output": "Code quality analysis report (e.g., TOOL_CODE_QUALITY_REPORT.md)",
              "note": "For meta-analysis (Reflow analyzing itself), D-02 validates existing tools/workflows rather than implementing new code"
            }
          },
          "source": "data_models from service_architecture.json (greenfield) OR existing codebase (meta-analysis)",
          "pattern": "Domain-driven design principles (greenfield) OR code analysis best practices (meta-analysis)"
        },
        {
          "action_id": "D-02-A02",
          "description": "Implement business logic components",
          "source": "components from service_architecture.json system_view",
          "purpose": "Create services, repositories, use cases",
          "follows": "Clean architecture or hexagonal architecture patterns"
        },
        {
          "action_id": "D-02-A03",
          "description": "Implement internal interfaces",
          "source": "internal interfaces from component specifications",
          "purpose": "Define contracts between components within a service"
        },
        {
          "action_id": "D-02-A04",
          "description": "Create unit tests for domain logic",
          "coverage_requirement": "Minimum 80% code coverage",
          "purpose": "Ensure domain logic correctness",
          "location_pattern": "services/{service_name}/tests/unit/"
        },
        {
          "action_id": "D-02-A99",
          "description": "Prove It Works - Validate service runs with domain model implementation",
          "when": "After all D-02 actions complete, before proceeding to D-03",
          "purpose": "Catch deployment issues incrementally when introduced, not all at once during operational testing",
          "new_in_version": "v3.6.0 - Early Testing Integration",
          "time_budget": "15-30 minutes (mostly automated)",
          "blocking": false,
          "enforcement": "STRONGLY RECOMMENDED to fix issues before proceeding",
          "validation_checks": [
            "Docker build succeeds (docker build --no-cache)",
            "Service starts in container",
            "Health endpoint responds 200 OK",
            "Logs clean (no ERROR/WARNING at startup)",
            "Basic smoke test passes (create one entity via API)"
          ],
          "benefit": "Deployment issues caught incrementally (per development step) instead of all at once during operational testing"
        }
      ],
      "tools_used": [],
      "templates_used": [
        "Language-specific templates from templates/language_templates/"
      ],
      "outputs": [
        "services/{service_name}/src/ (domain models, business logic)",
        "services/{service_name}/tests/unit/ (unit tests)"
      ],
      "gates": [
        {
          "gate_id": "G-D-02",
          "name": "Domain Model Completeness",
          "checks": [
            "All domain models from service_architecture.json implemented",
            "Unit tests exist for business logic",
            "Unit tests passing"
          ],
          "blocking": false
        }
      ]
    },
    {
      "step_id": "D-04",
      "name": "Integration Surfaces & Security Hardening",
      "description": "Implement external interfaces and security controls",
      "phase": "implementation",
      "step_file": "workflow_steps/development/D-04-IntegrationAndSecurity.json",
      "maps_from": "Dev-04: Integration Surfaces & Security Hardening",
      "actions": [
        {
          "action_id": "D-04-A01",
          "description": "Implement API endpoints",
          "source": "Interface Contract Documents (ICDs) from specs/machine/interfaces/",
          "purpose": "Expose service capabilities via APIs",
          "follows": "REST, GraphQL, gRPC, or other API patterns"
        },
        {
          "action_id": "D-04-A02",
          "description": "Implement API clients for dependencies",
          "source": "Outbound interfaces from interface_registry.json",
          "purpose": "Call other services or external systems"
        },
        {
          "action_id": "D-04-A03",
          "description": "Implement authentication",
          "source": "Security constraints from service_architecture.json",
          "methods": [
            "JWT",
            "OAuth 2.0",
            "API keys",
            "mTLS"
          ],
          "purpose": "Verify user/service identity"
        },
        {
          "action_id": "D-04-A04",
          "description": "Implement authorization",
          "patterns": [
            "RBAC (Role-Based Access Control)",
            "ABAC (Attribute-Based)",
            "Policy-based"
          ],
          "purpose": "Control access to resources"
        },
        {
          "action_id": "D-04-A05",
          "description": "Implement input validation and sanitization",
          "purpose": "Prevent injection attacks and malformed input",
          "applies_to": "All API endpoints"
        },
        {
          "action_id": "D-04-A06",
          "description": "Verify interface contracts",
          "tool": "verify_component_contract.py",
          "command_pattern": "python3 {reflow_root}/tools/verify_component_contract.py {system_root} --service {service_name}",
          "purpose": "Ensure implementations satisfy ICDs"
        },
        {
          "action_id": "D-04-A07",
          "description": "Create integration tests",
          "types": [
            "API contract tests",
            "Integration tests",
            "Security tests"
          ],
          "location_pattern": "services/{service_name}/tests/integration/"
        },
        {
          "action_id": "D-04-A99",
          "description": "Prove It Works - Validate service runs with integration and security",
          "when": "After all D-04 actions complete, before proceeding to D-05",
          "purpose": "Catch integration and authentication issues incrementally when introduced",
          "new_in_version": "v3.6.0 - Early Testing Integration",
          "time_budget": "15-30 minutes (mostly automated)",
          "blocking": false,
          "enforcement": "STRONGLY RECOMMENDED to fix issues before proceeding",
          "validation_checks": [
            "Docker build succeeds",
            "Service starts and connects to dependencies",
            "Health endpoint responds 200 OK",
            "Authentication works (valid token accepted, invalid rejected)",
            "Logs clean (no ERROR/WARNING at startup)",
            "Integration smoke test passes (call one endpoint, verify response)"
          ],
          "benefit": "Integration and security issues caught immediately, not during operational testing"
        }
      ],
      "tools_used": [
        "verify_component_contract.py"
      ],
      "outputs": [
        "services/{service_name}/src/ (API layer, clients, security)",
        "services/{service_name}/tests/integration/ (integration tests)"
      ],
      "gates": [
        {
          "gate_id": "G-D-04",
          "name": "Interface Contract Compliance",
          "checks": [
            "All ICDs implemented",
            "verify_component_contract.py passes for all services",
            "Integration tests passing",
            "Security controls in place"
          ],
          "blocking": true
        }
      ]
    }
  ],
  "quality_gates": {
    "gates": []
  },
  "next_workflow": "03b-development_validation"
}