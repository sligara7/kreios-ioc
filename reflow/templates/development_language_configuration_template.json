{
  "template_version": "1.0",
  "template_description": "Development language configuration template for multi-language or single-language systems",
  "system_name": "REPLACE_WITH_SYSTEM_NAME",
  "configuration_type": "REQUIRED: homogeneous | heterogeneous",
  "default_language": "OPTIONAL: Primary language for the system (most common in heterogeneous systems)",
  "default_framework": "OPTIONAL: Primary framework for the default language",
  "service_languages": {
    "SERVICE_ID_1": {
      "language": "REQUIRED: python | java | javascript | typescript | go | rust | ruby | csharp",
      "framework": "REQUIRED: Framework specific to the language (e.g., fastapi, spring-boot, express)",
      "rationale": "REQUIRED: Explanation for language choice based on service requirements",
      "specific_considerations": [
        "Performance requirements",
        "Library ecosystem needs", 
        "Integration requirements",
        "Team expertise"
      ]
    },
    "SERVICE_ID_2": {
      "language": "LANGUAGE_NAME",
      "framework": "FRAMEWORK_NAME",
      "rationale": "RATIONALE_FOR_CHOICE"
    }
  },
  "rationale": {
    "configuration_choice": "REQUIRED: Why homogeneous vs heterogeneous was chosen",
    "primary_considerations": [
      "Team expertise and familiarity",
      "Performance and scalability requirements",
      "Library and ecosystem availability",
      "Operational complexity vs benefits"
    ]
  },
  "development_setup": {
    "LANGUAGE_NAME": {
      "runtime_requirements": [
        "Runtime version requirements",
        "Package manager requirements",
        "Build tool requirements"
      ],
      "framework_setup": {
        "FRAMEWORK_NAME": "Installation and setup commands"
      },
      "development_tools": [
        "Recommended formatters",
        "Linting tools",
        "Testing frameworks"
      ],
      "testing_frameworks": [
        "Unit testing frameworks",
        "Integration testing tools",
        "Contract testing tools"
      ],
      "deployment_considerations": {
        "containerization": "Docker setup approach",
        "runtime_dependencies": "Production runtime requirements",
        "monitoring_tools": "Language-specific monitoring and observability"
      }
    }
  },
  "interface_contract_compliance": {
    "description": "How language diversity maintains black-box architecture principles",
    "contract_enforcement": [
      "All services must implement declared interfaces regardless of language",
      "Interface contracts are language-agnostic (JSON, HTTP, gRPC, etc.)",
      "Service internal implementation is completely encapsulated",
      "Inter-service communication only through defined interface protocols"
    ],
    "validation_approach": [
      "Contract testing validates interface compliance",
      "Integration tests verify cross-language service communication",
      "Interface specifications serve as single source of truth"
    ]
  },
  "operational_considerations": {
    "deployment_strategy": "REQUIRED: How different languages will be deployed (containers, serverless, etc.)",
    "monitoring_approach": "REQUIRED: Unified monitoring across different language services",
    "logging_strategy": "REQUIRED: Consistent logging format across languages",
    "debugging_approach": "REQUIRED: How to debug issues across multi-language services"
  },
  "migration_strategy": {
    "description": "Optional: Strategy for migrating services between languages if needed",
    "considerations": [
      "Interface contracts enable language-agnostic migration",
      "Service boundaries provide natural migration points",
      "Gradual migration approach service by service"
    ]
  },
  "configuration_metadata": {
    "created_date": "YYYY-MM-DD",
    "created_by": "Tool or user that created this configuration",
    "last_updated": "YYYY-MM-DD",
    "version": "1.0"
  }
}