{
  "$schema": "../templates/schemas/service_architecture_schema.json",
  "template_version": "1.0",
  "template_description": "Standard template for service_architecture.json files based on UAF definitions",
  "CRITICAL_NOTE": "service_id and service_name MUST be at TOP LEVEL (not nested in metadata). Tools expect flat structure.",
  "service_name": "REPLACE_WITH_SERVICE_NAME",
  "service_id": "REPLACE_WITH_SERVICE_ID",
  "hierarchical_tier": "REQUIRED: tier_0_system_of_systems | tier_1_systems | tier_2_components",
  "component_classification": "REQUIRED: service | function | external | interface_protocol",
  "purpose": "REPLACE_WITH_PURPOSE_DESCRIPTION",
  "dependencies": [
    "DEPENDENT_SERVICE_ID_1",
    "DEPENDENT_SERVICE_ID_2"
  ],
  "interfaces": [
    {
      "name": "INTERFACE_NAME",
      "interface_type": "REQUIRED: http_endpoint | message | data_contract | service_dependency | auth_requirement | cache_requirement | storage_requirement | architectural_constraint",
      "communication_pattern": "REQUIRED: synchronous | asynchronous | bidirectional",
      "dependency_type": "REQUIRED: direct | indirect | external",
      "path": "OPTIONAL: /api/path (for HTTP endpoints)",
      "method": "OPTIONAL: GET | POST | PUT | DELETE | PATCH (for HTTP endpoints)",
      "description": "INTERFACE_DESCRIPTION",
      "auth_required": false,
      "version": "1.0",
      "implementation_status": "REQUIRED: existing | recommended | hypothetical",
      "source_verification": "REQUIRED: Based on actual source code | Recommended solution | Educated guess - need verification"
    }
  ],
  "is_external": false,
  "parent_system": "REPLACE_WITH_PARENT_SYSTEM_NAME",
  "security": {
    "api_key_authentication": false,
    "ssl_tls": false,
    "additional_requirements": []
  },
  "deployment": {
    "ansible_managed": false,
    "systemd_service": false,
    "python_uvicorn": false,
    "docker_container": false,
    "ports": {
      "primary": {
        "port": 8000,
        "protocol": "HTTP",
        "purpose": "Main API endpoint",
        "binding": "0.0.0.0",
        "public_facing": true,
        "health_check_path": "/health",
        "note": "Port assigned from port_registry.json - must be unique across all services"
      },
      "metrics": {
        "port": 9000,
        "protocol": "HTTP",
        "purpose": "Prometheus metrics",
        "binding": "0.0.0.0",
        "public_facing": false,
        "note": "Optional - only if service exposes metrics"
      },
      "admin": {
        "port": null,
        "protocol": "HTTP",
        "purpose": "Admin interface (optional)",
        "binding": "127.0.0.1",
        "public_facing": false,
        "note": "Optional - localhost only if needed"
      }
    },
    "docker_mapping": {
      "host_port": 8000,
      "container_port": 8000,
      "note": "Typically host_port == container_port for simplicity. Defined in port_registry.json."
    },
    "additional_info": {}
  },
  "performance": {
    "expected_load": "OPTIONAL: low | medium | high",
    "scaling_strategy": "OPTIONAL: horizontal | vertical | none",
    "resource_requirements": {}
  },
  "version": "REQUIRED: X.Y+YYYY-MM-DD (semver-date format)",
  "source_references": {
    "github_repo": "OPTIONAL: GitHub repository URL if component exists",
    "documentation_links": ["OPTIONAL: Documentation URLs"],
    "analysis_date": "YYYY-MM-DD",
    "confidence_level": "REQUIRED: high | medium | low"
  },
  "implementation_status": "REQUIRED: existing | recommended | hypothetical",
  "verification_notes": "REQUIRED: Explain whether this is based on actual source analysis, recommendations, or educated guesses",
  "justification": {
    "rationale": "REQUIRED when status is 'recommended' or 'hypothetical': Specific reason for this design choice",
    "standards_reference": "OPTIONAL: Industry standards, RFCs, or specifications that support this approach",
    "best_practices_reference": "OPTIONAL: Well-established patterns or practices this follows",
    "examples": "OPTIONAL: Similar implementations or systems that use this pattern",
    "trade_offs": "OPTIONAL: Why this approach was chosen over alternatives"
  },
  "INSTRUCTIONS": {
    "CRITICAL_STRUCTURE_REQUIREMENT": "DO NOT nest service_id/service_name in a 'metadata' object. They MUST be at top level of JSON. Tools (system_of_systems_graph_v2.py) expect: data.get('service_id'), NOT data.get('metadata', {}).get('service_id')",
    "hierarchical_tier_rules": {
      "tier_0_system_of_systems": "Highest level federation of multiple independent systems",
      "tier_1_systems": "Independent systems that can operate standalone",
      "tier_2_components": "Individual services and components within a system"
    },
    "component_classification_rules": {
      "service": "Black-box functionality exposed to external consumers",
      "function": "Internal behavior within a service",
      "external": "External/non-modifiable systems (IOCs, databases, legacy)",
      "interface_protocol": "Data transport mechanisms (EPICS/CA, protocols)"
    },
    "communication_pattern_rules": {
      "synchronous": "Request-response, caller waits for response",
      "asynchronous": "Fire-and-forget, pub-sub, event-driven",
      "bidirectional": "Two-way communication, both parties can initiate"
    },
    "dependency_type_rules": {
      "direct": "Component directly communicates with another",
      "indirect": "Communication through intermediary service", 
      "external": "Dependency on service outside current system boundary"
    },
    "required_fields": [
      "service_name",
      "service_id", 
      "hierarchical_tier",
      "component_classification",
      "purpose",
      "dependencies",
      "interfaces",
      "is_external",
      "version"
    ],
    "validation_rules": [
      "service_id must be lowercase with underscores",
      "version must follow semver-date: X.Y+YYYY-MM-DD",
      "dependencies array must contain valid service_ids that exist in the system",
      "interfaces array must have at least one interface unless is_external=true",
      "implementation_status must be one of: existing, recommended, hypothetical",
      "For 'recommended' or 'hypothetical' status, justification.rationale is required"
    ]
  }
}