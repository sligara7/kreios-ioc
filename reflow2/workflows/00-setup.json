{
  "workflow_metadata": {
    "workflow_id": "00-setup",
    "name": "Setup Workflow",
    "version": "1.0.0",
    "description": "Initialize system, configure paths, set up environment and foundational documents",
    "created_from": "decision_flow.json v2.5.0 - extracted Arch-00, Arch-01, and initialization logic",
    "last_updated": "2025-10-24",
    "purpose": "Establish all prerequisites for architecture and development workflows"
  },
  "path_configuration": {
    "description": "Critical path setup - all paths must be absolute for tool invocations",
    "required_paths": {
      "reflow_root": {
        "description": "Where reflow tooling is installed (e.g., /home/user/dev/reflow)",
        "must_contain": ["tools/", "templates/", "definitions/", "workflows/", "workflow_steps/"],
        "verification": "Check for presence of core directories",
        "stored_in": "system context/working_memory.json"
      },
      "system_root": {
        "description": "Where the system being developed is located (e.g., /home/user/projects/my_system)",
        "must_contain": ["context/", "specs/", "docs/"],
        "created_by": "This workflow",
        "stored_in": "system context/working_memory.json"
      },
      "workflow_steps_path": {
        "description": "Path to workflow step definitions",
        "default": "{reflow_root}/workflow_steps",
        "stored_in": "system context/working_memory.json"
      },
      "tools_path": {
        "description": "Path to reflow tools",
        "default": "{reflow_root}/tools",
        "stored_in": "system context/working_memory.json"
      },
      "templates_path": {
        "description": "Path to reflow templates",
        "default": "{reflow_root}/templates",
        "stored_in": "system context/working_memory.json"
      }
    },
    "path_best_practices": [
      "Store reflow tools in one location (e.g., ~/dev/reflow/)",
      "Store each system in its own location (e.g., ~/projects/system_name/)",
      "Use absolute paths when invoking tools to avoid confusion",
      "Within system files, always use relative paths for portability",
      "Never assume systems are in reflow/systems/ directory"
    ]
  },
  "entry_points": {
    "new_system": {
      "id": "new_system",
      "description": "Starting a brand new system or concept",
      "trigger": "User wants to create a new system from scratch",
      "first_step": "S-01"
    },
    "new_concept_or_system": {
      "id": "new_concept_or_system",
      "description": "New concept that may become one or more systems",
      "trigger": "User has a new idea to develop",
      "first_step": "S-01"
    },
    "system_of_systems": {
      "id": "system_of_systems",
      "description": "Multi-system integration project",
      "trigger": "User wants to create a system-of-systems architecture",
      "first_step": "S-01",
      "optional_step": "S-04"
    }
  },
  "context_management": {
    "description": "Prevent context drift and token exhaustion during workflow execution",
    "template_reference": "See templates/context_management_template.json for complete details",
    "rag_enhanced_mode": {
      "description": "RECOMMENDED - Use RAG for automatic context injection and degradation detection",
      "setup": "Initialize in S-03-A05 (Setup workflow)",
      "benefits": "Automatic retrieval, degradation detection, systematic rule enforcement",
      "usage": "Use rag_agent_wrapper.py to wrap queries: python3 {reflow_root}/tools/rag_agent_wrapper.py {system_root} wrap --query 'your query' --strategy on_step_start",
      "fallback": "If RAG not set up, use manual context management below"
    },
    "operations_counter": {
      "threshold": 5,
      "tracking_location": "context/working_memory.json (operations_since_refresh field)",
      "rule": "Increment after each real operation (file creation, tool execution, artifact generation)",
      "refresh_trigger": "When >= 5, execute refresh sequence immediately",
      "rag_alternative": "RAG provides automatic periodic refresh every 4 operations or 12 minutes"
    },
    "degradation_signals_watch_for": [
      "Asking about system name (it's in working_memory.json)",
      "Forgetting current step",
      "Working in wrong directory (pwd != system_root)",
      "Using wrong template format",
      "Repetitive errors (same error 2+ times)",
      "Generating unwanted reports or summaries"
    ],
    "degradation_detection_tools": {
      "rag_automatic": "If RAG enabled, use: python3 {reflow_root}/tools/rag_agent_wrapper.py {system_root} analyze --response response.txt",
      "manual": "If RAG not enabled, watch for degradation signals above and manually trigger refresh"
    },
    "refresh_sequence_summary": [
      "1. PAUSE - Stop all operations",
      "2. VERIFY PWD - Confirm in correct directory",
      "3. SAVE STATE - Update working_memory.json and step_progress_tracker.json",
      "4. RELOAD - Read workflow file, definitions, templates (OR use RAG wrapper for automatic injection)",
      "5. READ - current_focus.md and step_progress_tracker.json",
      "6. CONFIRM - State system name, workflow, step, next action",
      "7. RESET - Set operations_since_refresh = 0",
      "8. RESUME - Continue with confirmed action"
    ],
    "pre_operation_checklist": [
      "Verify pwd equals system_root",
      "Read current_focus.md (OR use RAG wrapper for automatic context)",
      "Read step_progress_tracker.json",
      "Verify action matches current step",
      "Check operations_since_refresh <= 4"
    ],
    "rag_tools_available": [
      "rag_agent_wrapper.py wrap - Wrap query with relevant context",
      "rag_agent_wrapper.py analyze - Detect degradation in responses",
      "rag_agent_wrapper.py validate - Pre-operation validation",
      "rag_agent_wrapper.py refresh - Force context refresh",
      "generate_rag_embeddings.py --force-rebuild - Rebuild embeddings if workflows updated"
    ]
  },
  "self_improvement": {
    "description": "Continuous workflow improvement through observation and metrics",
    "template_reference": "See templates/self_improvement_template.json for complete details",
    "during_execution": {
      "observe": ["Time efficiency", "Error patterns", "Quality gate effectiveness", "Tool performance", "Documentation gaps"],
      "document": "Log observations to context/process_log.md with timestamps",
      "track_metrics": "Update context/workflow_metrics.json after each step"
    },
    "after_completion": {
      "retrospective_file": "context/workflow_retrospective_00-setup_{date}.md",
      "key_questions": [
        "What worked well?",
        "What was confusing?",
        "What could be automated?",
        "What took longer than expected?"
      ],
      "improvement_submission": "Add entries to WORKFLOW_IMPROVEMENTS_BACKLOG.md"
    }
  },
  "workflow_steps": [
    {
      "step_id": "S-01",
      "name": "Path Configuration",
      "description": "Configure all required paths for reflow operation",
      "phase": "initialization",
      "step_file": "workflow_steps/setup/S-01-PathConfiguration.json",
      "actions": [
        {
          "action_id": "S-01-A01",
          "description": "Identify and validate reflow_root path",
          "verification": "Ensure reflow_root contains tools/, templates/, definitions/, workflows/",
          "store_in": "context/working_memory.json under paths.reflow_root"
        },
        {
          "action_id": "S-01-A02",
          "description": "Identify or create system_root path",
          "verification": "Confirm system directory exists or create it",
          "store_in": "context/working_memory.json under paths.system_root"
        },
        {
          "action_id": "S-01-A03",
          "description": "Derive and store all tool paths",
          "details": "Calculate paths.tools_path, paths.templates_path, paths.workflow_steps_path, paths.definitions_path",
          "store_in": "context/working_memory.json"
        },
        {
          "action_id": "S-01-A04",
          "description": "Run validate_reflow_setup.py",
          "command_pattern": "python3 {reflow_root}/tools/validate_reflow_setup.py {system_root}",
          "success_criteria": "All validation checks pass"
        }
      ],
      "tools_used": ["validate_reflow_setup.py"],
      "outputs": ["context/working_memory.json with complete path configuration"],
      "gates": [],
      "next_step": "S-01A"
    },
    {
      "step_id": "S-01A",
      "name": "Architectural Framework Selection",
      "description": "Critically analyze and select the architectural framework appropriate for the system being modeled",
      "phase": "initialization",
      "step_file": "workflow_steps/setup/S-01A-FrameworkSelection.json",
      "rationale": "Framework selection is an ARCHITECTURAL DECISION, not a configuration choice. Wrong framework = wrong insights. This step requires EXPLICIT ANALYSIS of all frameworks against system semantics and user confirmation before proceeding.",
      "critical_lesson": "LESSON-01: Do NOT default to UAF! Analyze system semantics (state machines? services? agents? species?) against ALL frameworks. Framework choice determines which NetworkX analyses are available.",
      "actions": [
        {
          "action_id": "S-01A-A01",
          "description": "Analyze system domain and characteristics with semantic matching",
          "purpose": "Understand system semantics BEFORE selecting framework - match abstractions, not just domain",
          "rationale": "LESSON-04: Framework abstractions must match system semantics. Workflows are state machines (not services), even though both could be 'engineered systems'. Wrong abstraction = wrong insights.",
          "llm_instructions": [
            "Ask user to describe the system in their own words",
            "Apply semantic matching questionnaire (below) to understand system nature",
            "Document answers for framework comparison"
          ],
          "semantic_matching_questionnaire": {
            "question_1": {
              "question": "What are your primary entities (nodes)?",
              "answers_map_to": {
                "Services that communicate via APIs": "UAF framework",
                "States in a process with transitions": "Decision Flow framework",
                "Agents with relationships": "Social Network framework",
                "Species in an ecosystem": "Ecological framework",
                "Genes, proteins, or molecules": "Systems Biology framework",
                "Adaptive agents that learn": "Complex Adaptive Systems framework"
              },
              "critical": "Match entity semantics, not just domain. A workflow step is a STATE, not a SERVICE."
            },
            "question_2": {
              "question": "What are your connections (edges)?",
              "answers_map_to": {
                "API calls or data interfaces": "UAF framework",
                "State transitions with conditions": "Decision Flow framework",
                "Social relationships or interactions": "Social Network framework",
                "Energy/matter flow or species interactions": "Ecological framework",
                "Molecular interactions (activation, inhibition)": "Systems Biology framework",
                "Adaptive interactions with feedback": "Complex Adaptive Systems framework"
              },
              "critical": "Edges represent different things in each framework. Workflow transitions â‰  API calls."
            },
            "question_3": {
              "question": "Do edges have conditions or branching?",
              "answers_map_to": {
                "Yes, if/else routing or decision points": "Decision Flow framework (conditional transitions)",
                "Yes, but based on agent decisions": "Social Network or CAS framework",
                "No, always connected": "UAF, Social Network (static connections)",
                "Yes, based on environmental factors": "Ecological or Systems Biology framework"
              }
            },
            "question_4": {
              "question": "Are cycles expected behavior or errors?",
              "answers_map_to": {
                "Expected - feedback loops are essential": "Systems Biology, CAS, Ecological (regulatory feedback)",
                "Expected - rework loops are normal": "Decision Flow (validation failures, retries)",
                "Errors - circular dependencies are bad": "UAF (service dependencies should be acyclic)",
                "Neither - cycles not relevant": "Consider simpler modeling approach"
              },
              "critical": "Cycle semantics determine framework choice. UAF cycles = bugs. Biology cycles = features."
            },
            "question_5": {
              "question": "Do you need to analyze flow, throughput, or bottlenecks?",
              "answers_map_to": {
                "Yes, need to find workflow bottlenecks": "Decision Flow (requires edge weights: probabilities)",
                "Yes, need to track energy flow": "Ecological (requires edge weights: energy transfer rates)",
                "Yes, need to analyze reaction rates": "Systems Biology (requires edge weights: reaction rates)",
                "No, just need connectivity analysis": "Any framework works (centrality, community, etc.)"
              },
              "critical": "Flow analysis REQUIRES edge weights. If you need flow, choose framework that supports weights."
            },
            "question_6": {
              "question": "What is the system's primary behavior?",
              "answers_map_to": {
                "Sequential processing with decision points": "Decision Flow framework",
                "Services responding to requests": "UAF framework",
                "Agents interacting and influencing each other": "Social Network or CAS framework",
                "Species competing and cooperating": "Ecological framework",
                "Molecules regulating each other": "Systems Biology framework",
                "Emergent behavior from simple rules": "Complex Adaptive Systems framework"
              }
            }
          },
          "semantic_matching_decision_tree": {
            "start": "What are your nodes?",
            "if_states": "Are transitions conditional?",
            "if_conditional_transitions": "â†’ Decision Flow Framework",
            "if_sequential_only": "â†’ Decision Flow or UAF (check if states vs services)",
            "if_services": "Do services have human users?",
            "if_services_with_users": "â†’ UAF with IT requirements (security, deployment, UX)",
            "if_services_internal": "â†’ UAF (simpler security acceptable)",
            "if_agents": "Do agents adapt and learn?",
            "if_adaptive_agents": "â†’ Complex Adaptive Systems",
            "if_static_agents": "â†’ Social Network Analysis",
            "if_species": "â†’ Ecological Systems Framework",
            "if_molecules": "â†’ Systems Biology Framework",
            "if_hybrid": "â†’ Custom Framework (research domain)"
          },
          "examples_correct_vs_incorrect": {
            "correct": [
              "Microservices system â†’ UAF (services communicating via APIs)",
              "Reflow workflows â†’ Decision Flow (states with conditional transitions)",
              "Gene regulatory network â†’ Systems Biology (molecular interactions)",
              "Corporate org chart â†’ Social Network (people with relationships)",
              "Food web â†’ Ecological (species with predation/competition)",
              "Stock market â†’ CAS (adaptive agents with emergent behavior)"
            ],
            "incorrect": [
              "âŒ Reflow workflows â†’ UAF (WRONG: steps â‰  services, misses decision logic)",
              "âŒ Social network â†’ UAF (WRONG: relationships â‰  interfaces)",
              "âŒ Food web â†’ UAF (WRONG: predation â‰  API calls)",
              "âŒ Gene network â†’ Social Network (WRONG: molecular regulation â‰  social relationships)"
            ]
          },
          "output": "System characteristics summary with semantic matching answers"
        },
        {
          "action_id": "S-01A-A02",
          "description": "Analyze ALL frameworks against system characteristics",
          "purpose": "Evaluate EVERY framework, not just pick one",
          "llm_instructions": [
            "Load definitions/framework_registry.json",
            "For EACH of the 7 frameworks (UAF, Decision Flow, Systems Biology, Social Network, Ecological, CAS, Custom):",
            "  - Evaluate: Does system domain match framework domain?",
            "  - Evaluate: Do system entities match framework node types?",
            "  - Evaluate: Do system connections match framework edge types?",
            "  - Evaluate: Which NetworkX analyses does this framework enable?",
            "  - Evaluate: What insights would this framework reveal?",
            "  - Evaluate: What insights would this framework MISS?",
            "Create comparison table showing each framework's fit"
          ],
          "required_fields_to_check": [
            "framework.domain",
            "framework.node_types",
            "framework.edge_types",
            "framework.recommended_analyses",
            "framework.edge_schema (does it support weights?)"
          ],
          "output": "Framework analysis comparison table"
        },
        {
          "action_id": "S-01A-A03",
          "description": "Map NetworkX analyses to each framework",
          "purpose": "Show which analyses each framework enables/blocks",
          "llm_instructions": [
            "For each framework, list which NetworkX analyses are:",
            "  - AVAILABLE: Can be run with this framework",
            "  - BLOCKED: Cannot be run (e.g., flow analysis requires edge weights)",
            "  - SEMANTIC: Have different meaning (cycles = rework loops vs circular deps)",
            "Create NetworkX analysis availability matrix",
            "Highlight analyses that are HIGH priority for this system"
          ],
          "example_output": {
            "uaf": {
              "flow_analysis": "BLOCKED - No edge weights support",
              "cycle_detection": "AVAILABLE - Cycles indicate circular dependencies (BAD)",
              "dag_analysis": "AVAILABLE - Verify no circular service dependencies"
            },
            "decision_flow": {
              "flow_analysis": "AVAILABLE - Uses transition probabilities to find critical paths",
              "cycle_detection": "AVAILABLE - Cycles indicate rework loops (EXPECTED)",
              "dag_analysis": "AVAILABLE - Find sequential workflow paths"
            }
          },
          "output": "NetworkX analysis availability matrix"
        },
        {
          "action_id": "S-01A-A04",
          "description": "Score and recommend framework with objective criteria",
          "purpose": "Present LLM's framework recommendation to user with objective scoring",
          "rationale": "LESSON-06: Use objective scoring criteria to make framework selection transparent and defensible",
          "llm_instructions": [
            "Based on steps A01-A03 analysis, score EACH framework on 5 criteria",
            "Use scoring rubric below to calculate total scores",
            "Select framework with HIGHEST total score",
            "Prepare recommendation message including:",
            "  1. Recommended framework (highest score)",
            "  2. Score breakdown showing WHY this framework won",
            "  3. Comparison with 2nd and 3rd place frameworks",
            "  4. WHAT insights this framework will reveal",
            "  5. WHICH NetworkX analyses will be enabled",
            "Format as clear, structured message with scores visible"
          ],
          "framework_scoring_rubric": {
            "criterion_1_domain_match": {
              "name": "Domain Match",
              "weight": 2.0,
              "description": "How well does the framework's target domain match the system's domain?",
              "scoring": {
                "10": "Perfect match (e.g., microservices â†’ UAF, workflows â†’ Decision Flow)",
                "7-9": "Good match with minor misalignment",
                "4-6": "Partial match, framework can work but not ideal",
                "1-3": "Poor match, framework not designed for this domain",
                "0": "Complete mismatch"
              }
            },
            "criterion_2_semantic_match": {
              "name": "Semantic Match",
              "weight": 2.5,
              "description": "Do system entities match framework node/edge abstractions?",
              "scoring": {
                "10": "Perfect semantic match (states â†’ Decision Flow, services â†’ UAF, species â†’ Ecological)",
                "7-9": "Good match with reasonable interpretation",
                "4-6": "Forced fit, requires mental gymnastics",
                "1-3": "Poor fit, wrong abstractions (e.g., workflow steps as 'services')",
                "0": "Semantics completely incompatible"
              },
              "critical": "MOST IMPORTANT criterion. Wrong abstractions = wrong insights."
            },
            "criterion_3_analysis_match": {
              "name": "Required Analyses Availability",
              "weight": 2.0,
              "description": "Does framework enable the NetworkX analyses you need?",
              "scoring": {
                "10": "All required analyses available (e.g., need flow â†’ framework has edge weights)",
                "7-9": "Most analyses available, workarounds possible",
                "4-6": "Some analyses available, significant gaps",
                "1-3": "Few analyses available, major limitations",
                "0": "Critical analyses blocked (e.g., need flow but no edge weights)"
              }
            },
            "criterion_4_edge_weight_feasibility": {
              "name": "Edge Weight Feasibility",
              "weight": 1.5,
              "description": "If framework requires edge weights, can you provide them?",
              "scoring": {
                "10": "Edge weights not needed OR easily obtainable (historical data, domain knowledge)",
                "7-9": "Can estimate weights with reasonable accuracy",
                "4-6": "Weights difficult to obtain, rough estimates only",
                "1-3": "Weights very difficult, mostly guessing",
                "0": "Cannot provide weights but framework requires them",
                "N/A": "Framework doesn't use edge weights (score 10 by default)"
              }
            },
            "criterion_5_complexity": {
              "name": "Framework Complexity",
              "weight": 1.0,
              "description": "Prefer simpler frameworks if they meet requirements equally well",
              "scoring": {
                "10": "Very simple, easy to understand and apply",
                "7-9": "Moderate complexity, manageable",
                "4-6": "Complex, requires significant learning",
                "1-3": "Very complex, steep learning curve",
                "0": "Extremely complex, not practical"
              },
              "note": "Only use as tiebreaker if scores are close"
            }
          },
          "scoring_process": {
            "step_1": "Score each framework on all 5 criteria (0-10 scale)",
            "step_2": "Multiply each score by its weight",
            "step_3": "Sum weighted scores to get total (max 80 points)",
            "step_4": "Select framework with highest total score",
            "step_5": "Document scores for transparency"
          },
          "example_scoring_output": {
            "system": "Reflow Workflow System",
            "frameworks_scored": {
              "decision_flow": {
                "total_score": "9.2/10 (73.6/80 points)",
                "breakdown": {
                  "domain_match": "10/10 Ã— 2.0 = 20.0 (workflow system)",
                  "semantic_match": "10/10 Ã— 2.5 = 25.0 (states, not services)",
                  "analysis_match": "9/10 Ã— 2.0 = 18.0 (flow, cycles, paths all available)",
                  "edge_weight_feasibility": "8/10 Ã— 1.5 = 12.0 (can estimate probabilities)",
                  "complexity": "8/10 Ã— 1.0 = 8.0 (moderate)"
                },
                "recommendation": "âœ… RECOMMENDED - Highest score, perfect semantic match"
              },
              "uaf": {
                "total_score": "4.2/10 (33.6/80 points)",
                "breakdown": {
                  "domain_match": "8/10 Ã— 2.0 = 16.0 (engineered system)",
                  "semantic_match": "2/10 Ã— 2.5 = 5.0 (services â‰  states)",
                  "analysis_match": "3/10 Ã— 2.0 = 6.0 (DAG ok, but no flow)",
                  "edge_weight_feasibility": "2/10 Ã— 1.5 = 3.0 (no weight support)",
                  "complexity": "8/10 Ã— 1.0 = 8.0 (simple)"
                },
                "recommendation": "âŒ NOT RECOMMENDED - Poor semantic match, missing flow analysis"
              },
              "complex_adaptive": {
                "total_score": "6.5/10 (52.0/80 points)",
                "breakdown": {
                  "domain_match": "7/10 Ã— 2.0 = 14.0 (emergent behavior)",
                  "semantic_match": "6/10 Ã— 2.5 = 15.0 (adaptive agents)",
                  "analysis_match": "7/10 Ã— 2.0 = 14.0 (cycles, SCC available)",
                  "edge_weight_feasibility": "6/10 Ã— 1.5 = 9.0 (interaction strength unclear)",
                  "complexity": "5/10 Ã— 1.0 = 5.0 (complex)"
                },
                "recommendation": "âš ï¸ SECOND PLACE - Could work but less clear than Decision Flow"
              }
            }
          },
          "recommendation_template": {
            "recommended_framework": "framework_id (highest score)",
            "total_score": "X.X/10 (XX.X/80 points)",
            "score_breakdown": "Show weighted scores for all criteria",
            "comparison_with_alternatives": "Show 2nd and 3rd place scores",
            "rationale": "Why this framework won (semantic match, analysis availability)",
            "reveals": ["Insight 1", "Insight 2"],
            "enables_analyses": ["flow", "cycles", "centrality"],
            "alternatives_rejected": {
              "framework_name": "Rejected due to low score on [criterion]"
            }
          },
          "output": "Framework recommendation with objective scoring"
        },
        {
          "action_id": "S-01A-A05",
          "description": "Present recommendation to user and request confirmation",
          "purpose": "USER MUST EXPLICITLY CONFIRM framework selection",
          "user_prompt": {
            "message_format": "Framework Recommendation:\n\nRecommended: {framework_name}\n\nRationale:\n{rationale}\n\nThis framework reveals:\n{reveals_list}\n\nNetworkX analyses enabled:\n{enabled_analyses}\n\nAlternatives considered:\n{alternatives_rejected}\n\nâš ï¸ IMPORTANT: Framework selection determines entire analysis approach. Switching later requires re-doing all architecture files.\n\nConfirm: Proceed with {framework_name}? [Y/N]",
            "required": true,
            "blocking": true
          },
          "user_response_handling": {
            "if_yes": "Proceed to action S-01A-A06",
            "if_no": "Ask user which framework they prefer, re-analyze with that framework, re-present confirmation",
            "if_uncertain": "Provide additional guidance on framework tradeoffs"
          },
          "output": "User confirmation (Y/N)"
        },
        {
          "action_id": "S-01A-A06",
          "description": "User confirmed framework - load framework definition",
          "condition": "User confirmed YES in S-01A-A05",
          "command_pattern": "Read framework_registry.json and architectural_definitions_{framework}.json",
          "file_locations": [
            "{reflow_root}/definitions/framework_registry.json",
            "{reflow_root}/definitions/architectural_definitions_{selected_framework}.json"
          ],
          "note": "If custom framework selected, LLM researches domain and creates custom definitions file"
        },
        {
          "action_id": "S-01A-A07",
          "description": "Update working_memory.json with framework selection and analysis results",
          "purpose": "Document framework decision with complete rationale",
          "updates": {
            "framework_configuration": {
              "framework_id": "{selected_framework_id}",
              "framework_name": "{framework_display_name}",
              "component_term": "{node_term}",
              "connection_term": "{edge_term}",
              "architecture_file_type": "{architecture_file_type}",
              "selected_framework_rationale": "{detailed_rationale_from_A04}",
              "user_confirmed": true,
              "confirmation_timestamp": "{timestamp}"
            },
            "framework_analysis": {
              "system_characteristics": "{summary_from_A01}",
              "frameworks_evaluated": "{list_of_all_frameworks_analyzed}",
              "recommended_analyses": "{enabled_analyses_from_A03}",
              "alternatives_rejected": "{alternatives_from_A04}"
            }
          },
          "store_in": "context/working_memory.json"
        },
        {
          "action_id": "S-01A-A08",
          "description": "If custom framework: LLM research and definition creation",
          "condition": "selected_framework == 'custom'",
          "if_custom": {
            "research_steps": [
              "1. Ask user to describe the system domain and key entities",
              "2. Research domain literature (web search for 5-10 min)",
              "3. Identify common modeling approaches for this domain",
              "4. Create architectural_definitions_custom.json following pattern of other frameworks",
              "5. Create custom_node_template.json for architecture files",
              "6. User reviews and approves generated framework"
            ],
            "research_areas": [
              "Standard modeling approaches for this domain",
              "Common terminology (what are the 'nodes'? what are the 'edges'?)",
              "Validation criteria specific to this domain",
              "Quality attributes relevant to this system type"
            ],
            "output_files": [
              "{reflow_root}/definitions/architectural_definitions_custom.json",
              "{reflow_root}/templates/custom_node_template.json"
            ]
          }
        },
        {
          "action_id": "S-01A-A09",
          "description": "Display framework confirmation summary",
          "output_message": "âœ“ Framework selected: {framework_name}\\nâœ“ User confirmed: {confirmation_timestamp}\\nâœ“ System will use '{component_term}' nodes connected by '{connection_term}' edges\\nâœ“ NetworkX analyses enabled: {enabled_analyses}\\nâœ“ Definitions: {definitions_path}\\nâœ“ Template: {template_file}\\n\\nFramework selection complete. Rationale documented in working_memory.json."
        }
      ],
      "tools_used": [],
      "outputs": [
        "context/working_memory.json updated with framework selection and analysis rationale",
        "Framework analysis documented: system characteristics, alternatives evaluated, NetworkX analyses enabled",
        "Optionally: architectural_definitions_custom.json (if custom selected)"
      ],
      "gates": [
        {
          "gate_id": "G-S-01",
          "name": "Framework Selection Confirmation (BLOCKING)",
          "type": "BLOCKING",
          "severity": "critical",
          "rationale": "Framework selection is an architectural decision that determines entire analysis approach. User must explicitly confirm before proceeding.",
          "checks": [
            "System characteristics analyzed (working_memory.json framework_analysis.system_characteristics)",
            "ALL frameworks evaluated - at least 5 frameworks (working_memory.json framework_analysis.frameworks_evaluated)",
            "NetworkX analyses mapped to framework (working_memory.json framework_analysis.recommended_analyses)",
            "User explicitly confirmed framework selection (working_memory.json framework_configuration.user_confirmed == true)",
            "Detailed rationale documented (working_memory.json framework_configuration.selected_framework_rationale)"
          ],
          "failure_action": "Cannot proceed to S-02 without user confirmation. Re-execute S-01A-A05 to obtain confirmation.",
          "success_message": "âœ“ Framework selection confirmed by user. Rationale and analysis documented."
        }
      ],
      "next_step": "S-02",
      "notes": [
        "CRITICAL: Framework selection is NOT a default choice - it requires explicit analysis",
        "All frameworks map to the same core abstraction (nodes + edges) but enable different analyses",
        "Wrong framework = wrong insights (Example: UAF on workflows misses decision logic)",
        "Time investment: 10-15 min framework analysis saves hours of rework later",
        "Tools like system_of_systems_graph_v2.py work across all frameworks via framework adapters"
      ]
    },
    {
      "step_id": "S-02",
      "name": "Directory Structure Creation",
      "description": "Create standard system directory structure",
      "phase": "initialization",
      "step_file": "workflow_steps/setup/S-02-DirectoryStructure.json",
      "actions": [
        {
          "action_id": "S-02-A01",
          "description": "Create context/ directory",
          "purpose": "Store LLM agent tracking files (working_memory.json, step_progress_tracker.json, current_focus.md)",
          "command": "mkdir -p {system_root}/context"
        },
        {
          "action_id": "S-02-A02",
          "description": "Create specs/ directory structure",
          "purpose": "Store machine and human-readable specifications",
          "command": "mkdir -p {system_root}/specs/{machine,human}/{service_arch,interfaces,graphs,visualizations,documentation,reports}"
        },
        {
          "action_id": "S-02-A03",
          "description": "Create services/ directory",
          "purpose": "Store service implementations",
          "command": "mkdir -p {system_root}/services"
        },
        {
          "action_id": "S-02-A04",
          "description": "Create docs/ directory",
          "purpose": "Store foundational documents and system documentation",
          "command": "mkdir -p {system_root}/docs"
        },
        {
          "action_id": "S-02-A05",
          "description": "Run validate_directory_structure.py",
          "command_pattern": "python3 {reflow_root}/tools/validate_directory_structure.py {system_root}",
          "success_criteria": "All required directories exist"
        }
      ],
      "tools_used": ["validate_directory_structure.py"],
      "outputs": ["Complete system directory structure"],
      "gates": [],
      "next_step": "S-03"
    },
    {
      "step_id": "S-03",
      "name": "Foundational Documents",
      "description": "Create or validate foundational system documents",
      "phase": "initialization",
      "step_file": "workflow_steps/setup/S-03-FoundationalDocuments.json",
      "actions": [
        {
          "action_id": "S-03-A01",
          "description": "Create or validate SYSTEM_MISSION_STATEMENT.md",
          "location": "docs/SYSTEM_MISSION_STATEMENT.md",
          "content_requirements": [
            "Clear statement of system purpose",
            "Primary objectives",
            "Key stakeholders",
            "Success criteria at high level"
          ]
        },
        {
          "action_id": "S-03-A02",
          "description": "Create or validate USER_SCENARIOS.md",
          "location": "docs/USER_SCENARIOS.md",
          "content_requirements": [
            "Detailed user scenarios",
            "User personas",
            "Use cases",
            "User journey maps"
          ]
        },
        {
          "action_id": "S-03-A03",
          "description": "Create or validate SUCCESS_CRITERIA.md",
          "location": "docs/SUCCESS_CRITERIA.md",
          "content_requirements": [
            "Measurable success criteria",
            "Performance requirements",
            "Functional requirements",
            "Non-functional requirements"
          ]
        },
        {
          "action_id": "S-03-A04",
          "description": "Initialize working_memory.json",
          "tool": "bootstrap_development_context.py",
          "command_pattern": "python3 {reflow_root}/tools/bootstrap_development_context.py {system_root}",
          "creates": [
            "context/working_memory.json",
            "context/step_progress_tracker.json",
            "context/current_focus.md"
          ]
        },
        {
          "action_id": "S-03-A05",
          "description": "Initialize RAG-Enhanced Context Management (OPTIONAL but RECOMMENDED)",
          "purpose": "Set up automatic context retrieval to prevent drift and enforce workflow adherence",
          "tool": "generate_rag_embeddings.py",
          "optional": true,
          "recommended": "Strongly recommended to prevent context drift and systematic workflow enforcement",
          "setup_steps": [
            {
              "step": 1,
              "action": "Install RAG dependencies",
              "command": "pip install sentence-transformers faiss-cpu numpy",
              "check": "python3 -c 'import sentence_transformers, faiss, numpy'"
            },
            {
              "step": 2,
              "action": "Copy RAG configuration template",
              "command": "cp {reflow_root}/templates/rag_context_config_template.json {system_root}/context/rag_context_config.json"
            },
            {
              "step": 3,
              "action": "Edit RAG config and set system_name",
              "file": "{system_root}/context/rag_context_config.json",
              "update": "Set system_name field to match actual system name"
            },
            {
              "step": 4,
              "action": "Generate embeddings for knowledge bases",
              "command": "python3 {reflow_root}/tools/generate_rag_embeddings.py {system_root}",
              "creates": [
                "context/embeddings/decision_flow_embeddings.pkl",
                "context/embeddings/workflow_steps_embeddings.pkl",
                "context/embeddings/tool_reference_embeddings.pkl",
                "context/embeddings/architectural_definitions_embeddings.pkl",
                "context/embeddings/generation_summary.json"
              ],
              "duration": "1-3 minutes depending on workflow size"
            },
            {
              "step": 5,
              "action": "Verify RAG setup",
              "command": "cat {system_root}/context/embeddings/generation_summary.json",
              "success_criteria": "All knowledge bases generated successfully"
            }
          ],
          "benefits": [
            "Automatic context injection based on workflow state",
            "Degradation detection (report generation, workflow violations)",
            "Systematic enforcement of critical behavioral rules",
            "Token-efficient context retrieval (2000-8000 tokens vs 5000-10000 manual)",
            "Prevents LLM agents from forgetting workflow instructions"
          ],
          "rag_features": {
            "knowledge_bases": [
              "decision_flow_kb (workflow instructions and critical rules)",
              "workflow_steps_kb (step-specific guidance)",
              "tool_reference_kb (tool documentation)",
              "architectural_definitions_kb (UAF 1.2 terms)",
              "system_context_kb (runtime state)"
            ],
            "retrieval_strategies": [
              "on_step_start - Load workflow instructions for current step",
              "on_degradation_detected - Inject corrective context",
              "on_tool_execution - Load tool usage documentation",
              "on_user_query - Semantic search across all knowledge bases",
              "periodic_refresh - Auto-refresh every 4 operations or 12 minutes"
            ],
            "degradation_patterns": [
              "report_generation_attempt - Detects unwanted report generation",
              "workflow_violation - Detects skipping steps or ignoring workflow",
              "system_isolation_breach - Detects wrong directory or cross-system access",
              "context_confusion - Detects forgetting system name or current step"
            ]
          },
          "usage_in_workflows": {
            "manual_mode": "LLM agent manually reads working_memory.json and current_focus.md",
            "rag_enhanced_mode": "Use rag_agent_wrapper.py to automatically inject relevant context",
            "example": "python3 {reflow_root}/tools/rag_agent_wrapper.py {system_root} wrap --query 'Start next step' --strategy on_step_start"
          },
          "reference": "See {reflow_root}/docs/RAG_CONTEXT_MANAGEMENT.md for complete documentation"
        },
        {
          "action_id": "S-03-A06",
          "description": "Configure automatic git commits (OPTIONAL but RECOMMENDED)",
          "purpose": "Enable automatic version control commits at key workflow milestones",
          "user_prompt": {
            "ask": "Would you like to enable automatic git commits during workflow execution?",
            "options": [
              "Yes - Enable automatic git commits and pushes (recommended for version control)",
              "No - I'll manage git manually"
            ],
            "default": "No",
            "benefits": [
              "Automatic backup of architecture and code",
              "Version history of workflow progress",
              "Collaboration (others can see progress)",
              "Recovery from failures",
              "Meaningful commit messages at logical checkpoints"
            ]
          },
          "if_yes": {
            "git_setup": [
              {
                "step": 1,
                "action": "Check if git repo exists",
                "command": "cd {system_root} && git status",
                "outcomes": {
                  "success": "Git repo already exists, skip initialization",
                  "failure": "No git repo, proceed with initialization"
                }
              },
              {
                "step": 2,
                "action": "Initialize git repo if needed",
                "command": "cd {system_root} && git init",
                "condition": "Only if step 1 failed (no existing repo)"
              },
              {
                "step": 3,
                "action": "Create .gitignore file",
                "location": "{system_root}/.gitignore",
                "content": [
                  "# Python",
                  "__pycache__/",
                  "*.py[cod]",
                  "*$py.class",
                  "*.so",
                  ".Python",
                  "venv/",
                  "env/",
                  ".venv",
                  "*.egg-info/",
                  "",
                  "# IDEs",
                  ".vscode/",
                  ".idea/",
                  "*.swp",
                  "*.swo",
                  "*~",
                  "",
                  "# OS",
                  ".DS_Store",
                  "Thumbs.db",
                  "",
                  "# Secrets",
                  ".env",
                  "*.pem",
                  "*.key",
                  "credentials.json",
                  "",
                  "# Build artifacts",
                  "dist/",
                  "build/",
                  "*.egg",
                  "",
                  "# Test coverage",
                  ".coverage",
                  "htmlcov/",
                  "",
                  "# RAG embeddings (optional - large files)",
                  "# context/embeddings/*.pkl",
                  "",
                  "# Logs",
                  "*.log"
                ]
              },
              {
                "step": 4,
                "action": "Collect git configuration from user",
                "user_questions": [
                  {
                    "question": "What is your git remote repository URL?",
                    "examples": [
                      "https://github.com/username/repo.git",
                      "git@github.com:username/repo.git",
                      "https://gitlab.com/username/repo.git"
                    ],
                    "validation": "URL should end with .git",
                    "store_in": "context/git_config.json (git_remote_url)"
                  },
                  {
                    "question": "Which branch should automatic commits push to?",
                    "default": "main",
                    "examples": ["main", "develop", "architecture", "feature/workflow-automation"],
                    "store_in": "context/git_config.json (git_branch)"
                  },
                  {
                    "question": "Who should be credited as author for automatic commits?",
                    "default": "Claude Code <noreply@anthropic.com>",
                    "format": "Name <email>",
                    "examples": ["Claude Code <noreply@anthropic.com>", "Your Name <your@email.com>"],
                    "store_in": "context/git_config.json (git_author)"
                  }
                ]
              },
              {
                "step": 5,
                "action": "Configure git remote",
                "command": "cd {system_root} && git remote add origin {git_remote_url}",
                "fallback_if_exists": "git remote set-url origin {git_remote_url}",
                "verification": "git remote -v shows correct remote"
              },
              {
                "step": 6,
                "action": "Create initial git commit for setup",
                "commands": [
                  "cd {system_root}",
                  "git add .",
                  "git commit -m \"$(cat <<'EOF'\nInitial setup: Directory structure and foundational documents\n\n- Created directory structure (context/, specs/, docs/, services/)\n- Added foundational documents (SYSTEM_MISSION_STATEMENT.md, USER_SCENARIOS.md, SUCCESS_CRITERIA.md)\n- Initialized working_memory.json and workflow tracking\n- Configured automatic git commits\n\nðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)\n\nCo-Authored-By: Claude <noreply@anthropic.com>\nEOF\n)\"",
                  "git branch -M {git_branch}",
                  "git push -u origin {git_branch}"
                ],
                "error_handling": {
                  "if_push_fails": "Warn user but continue - they may need to configure git credentials or set up SSH keys",
                  "credential_help": "For HTTPS: git config --global credential.helper store\nFor SSH: Set up SSH keys with ssh-keygen and add to GitHub/GitLab",
                  "continue_on_failure": true
                }
              },
              {
                "step": 7,
                "action": "Save git configuration to working_memory.json",
                "update_fields": {
                  "git_automation_enabled": true,
                  "git_remote_url": "{git_remote_url}",
                  "git_branch": "{git_branch}",
                  "git_author": "{git_author}",
                  "last_git_commit": "{timestamp}"
                },
                "location": "context/working_memory.json"
              },
              {
                "step": 8,
                "action": "Create git commit helper function documentation",
                "location": "context/GIT_AUTOMATION_README.md",
                "content": "Documentation on when automatic commits occur and how to disable if needed"
              }
            ],
            "commit_schedule": {
              "description": "Automatic commits will occur at these workflow milestones",
              "00-setup": [
                "S-03-A06: After setup complete (initial commit)"
              ],
              "01-systems-engineering": [
                "SE-02: After each service architecture completed",
                "SE-06: After system graph generated and validated"
              ],
              "02-artifacts-visualization": [
                "AV-03: After human documentation generated",
                "AV-04: After visualizations created"
              ],
              "03-development": [
                "D-03: After each service foundation code completed",
                "D-03: After each service implementation completed and tests pass"
              ],
              "04-testing-operations": [
                "TO-02: After CI/CD pipeline configured",
                "TO-04: After successful deployment"
              ]
            }
          },
          "if_no": {
            "action": "Skip git setup, set git_automation_enabled: false in working_memory.json",
            "note": "User will manually manage git commits"
          },
          "llm_agent_instructions": [
            "ASK the user via AskUserQuestion tool if they want automatic git commits",
            "If YES: Execute git setup steps 1-8 in order",
            "Collect git remote URL and branch from user",
            "Create meaningful initial commit with workflow metadata",
            "Handle push failures gracefully (warn but continue)",
            "Document git configuration in working_memory.json",
            "If NO: Set git_automation_enabled: false and skip to next step"
          ],
          "success_criteria": [
            "User question asked and answered",
            "If yes: Git repo initialized/configured, initial commit made, working_memory.json updated",
            "If no: Git automation disabled in working_memory.json"
          ]
        }
      ],
      "tools_used": ["bootstrap_development_context.py", "generate_rag_embeddings.py (optional)"],
      "templates_used": [
        "working_memory_template.json",
        "step_progress_tracker_template.json",
        "current_focus_template.md",
        "rag_context_config_template.json (optional)"
      ],
      "outputs": [
        "docs/SYSTEM_MISSION_STATEMENT.md",
        "docs/USER_SCENARIOS.md",
        "docs/SUCCESS_CRITERIA.md",
        "context/working_memory.json",
        "context/step_progress_tracker.json",
        "context/current_focus.md",
        "context/git_config.json (if git automation enabled)",
        ".gitignore (if git automation enabled)"
      ],
      "gates": [
        {
          "gate_id": "G-S-03",
          "name": "Foundational Documents Complete",
          "checks": [
            "All three foundational documents exist",
            "Documents contain meaningful content (not just templates)",
            "working_memory.json initialized with correct paths"
          ]
        }
      ],
      "next_step": "S-04-decision"
    },
    {
      "step_id": "S-04-decision",
      "name": "System-of-Systems Decision",
      "description": "Determine if this is a system-of-systems integration project",
      "phase": "initialization",
      "decision_type": "user_input",
      "question": "Is this a system-of-systems integration project (multiple independent systems that need to work together)?",
      "options": {
        "yes": {
          "description": "Multi-system integration required",
          "next_step": "S-04"
        },
        "no": {
          "description": "Single system or standard service decomposition",
          "next_step": "complete",
          "transition_to": "01-systems_engineering"
        }
      }
    },
    {
      "step_id": "S-04",
      "name": "System-of-Systems Decomposition (Optional)",
      "description": "Decompose high-level concept into multiple independent systems",
      "phase": "initialization",
      "optional": true,
      "step_file": "workflow_steps/setup/S-04-SystemOfSystems.json",
      "when_to_use": "Multi-system integration projects where systems have independent lifecycles",
      "actions": [
        {
          "action_id": "S-04-A01",
          "description": "Analyze system-of-systems requirements",
          "purpose": "Identify independent systems that need integration",
          "creates": "Initial system-of-systems breakdown"
        },
        {
          "action_id": "S-04-A02",
          "description": "Define system boundaries",
          "purpose": "Clarify which capabilities belong to which system",
          "output": "System boundary definitions"
        },
        {
          "action_id": "S-04-A03",
          "description": "Identify integration points",
          "purpose": "Understand how systems will interact",
          "tool": "identify_integration_points.py (may be used later)"
        },
        {
          "action_id": "S-04-A04",
          "description": "Create separate system directories",
          "purpose": "Each system gets its own directory structure",
          "pattern": "Create {system_root}/../{system_name}/ for each identified system"
        }
      ],
      "tools_used": [],
      "outputs": [
        "Multiple system directories (one per system)",
        "System-of-systems documentation in docs/",
        "Integration requirements documented"
      ],
      "gates": [],
      "next_step": "complete",
      "transition_to": "01-systems_engineering",
      "note": "Each identified system will go through workflows independently, then integrate"
    }
  ],
  "completion": {
    "description": "Setup workflow complete - system is ready for architecture phase",
    "outputs_summary": [
      "System directory structure created",
      "All paths configured and validated",
      "Foundational documents created",
      "Context tracking initialized",
      "Optional: System-of-systems decomposed"
    ],
    "next_workflow": "01-systems_engineering",
    "transition_command": "workflow_driver.py {system_root} --next-workflow"
  },
  "llm_agent_guidance": {
    "critical_reminders": [
      "ALWAYS use absolute paths when invoking tools: python3 {reflow_root}/tools/<tool>.py {system_root}",
      "Store all path configuration in context/working_memory.json for future reference",
      "Verify reflow_root contains required directories before proceeding",
      "Never assume system is located in reflow/systems/ - it can be anywhere",
      "Use workflow_driver.py to track progress through setup steps"
    ],
    "common_mistakes": [
      "Using relative paths for tool invocation (causes 'file not found' errors)",
      "Not validating reflow_root directory structure",
      "Skipping foundational documents (causes issues in later workflows)",
      "Not initializing working_memory.json with path configuration"
    ]
  }
}
