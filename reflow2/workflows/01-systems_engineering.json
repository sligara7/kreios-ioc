{
  "workflow_metadata": {
    "workflow_id": "01-systems_engineering",
    "name": "Systems Engineering & Architecture Workflow",
    "version": "1.0.0",
    "description": "Design and validate complete system architecture, create machine-readable architecture products",
    "created_from": "decision_flow.json v2.5.0 - extracted Arch-02 through Arch-05",
    "last_updated": "2025-10-24",
    "purpose": "Create UAF-based service_architecture.json for each service and generate system_of_systems_graph.json",
    "based_on": "UAF 1.2 architecture framework"
  },
  "prerequisites": {
    "required_workflows": ["00-setup"],
    "required_files": [
      "context/working_memory.json (with paths configured)",
      "docs/SYSTEM_MISSION_STATEMENT.md",
      "docs/USER_SCENARIOS.md",
      "docs/SUCCESS_CRITERIA.md"
    ],
    "required_directories": [
      "specs/machine/service_arch/",
      "specs/machine/interfaces/",
      "specs/machine/graphs/"
    ]
  },
  "entry_points": {
    "auto": {
      "id": "auto",
      "description": "RECOMMENDED - LLM automatically detects bottom-up vs top-down by examining system directory",
      "first_step": "SE-00",
      "approach": "auto_detect",
      "detection_logic": {
        "description": "SE-00 examines system directory and routes to BU-01 (bottom-up) or SE-01 (top-down)",
        "indicators_of_existing_components": [
          "Source code directories (services/, src/, lib/, packages/, components/)",
          "Package manifests (package.json, requirements.txt, Cargo.toml, pom.xml, go.mod)",
          "Build files (Dockerfile, docker-compose.yml, Makefile, build.gradle)",
          "Existing architecture files (*.json in specs/machine/)",
          "Git history showing existing commits (not just initial commit)"
        ],
        "routing": {
          "if_components_found": "Route to BU-01 (bottom-up integration)",
          "if_empty_or_docs_only": "Route to SE-01 (top-down greenfield)"
        }
      }
    },
    "from_setup": {
      "id": "from_setup",
      "description": "LEGACY - Explicitly start top-down (greenfield). Use 'auto' instead for automatic detection.",
      "first_step": "SE-01",
      "approach": "top_down"
    },
    "from_existing_components": {
      "id": "from_existing_components",
      "description": "LEGACY - Explicitly start bottom-up (existing components). Use 'auto' instead for automatic detection.",
      "first_step": "BU-01",
      "approach": "bottom_up",
      "prerequisites": [
        "List of existing components (packages, services, systems) to integrate",
        "High-level integration goal",
        "Component source locations (GitHub repos, filesystem paths, package registries)"
      ],
      "when_to_use": [
        "Integrating 10+ Python packages into cohesive system",
        "Integrating legacy systems not designed to work together",
        "Need exact component-level deltas (function/module changes)",
        "Starting with existing components rather than requirements"
      ]
    }
  },
  "context_management": {
    "description": "Prevent context drift and token exhaustion during workflow execution",
    "template_reference": "See templates/context_management_template.json for complete details",
    "rag_enhanced_mode": {
      "description": "RECOMMENDED - Use RAG for automatic context injection and degradation detection",
      "setup": "Initialize in S-03-A05 (Setup workflow)",
      "benefits": "Automatic context refresh, degradation detection, token-efficient retrieval",
      "usage": "python3 {reflow_root}/tools/rag_agent_wrapper.py {system_root} wrap --query 'your query' --strategy on_step_start",
      "fallback": "If RAG not set up, use manual operations counter and refresh sequence below"
    },
    "operations_counter": {
      "threshold": 5,
      "tracking_location": "context/working_memory.json (operations_since_refresh field)",
      "rule": "Increment after each real operation (file creation, tool execution, artifact generation)",
      "refresh_trigger": "When >= 5, execute refresh sequence immediately"
    },
    "degradation_signals_watch_for": [
      "Asking about system name (it's in working_memory.json)",
      "Forgetting current step",
      "Working in wrong directory (pwd != system_root)",
      "Using wrong template format",
      "Creating artifacts in wrong locations",
      "Implementing features not in service_architecture.json"
    ],
    "refresh_sequence_summary": [
      "1. PAUSE - Stop all operations",
      "2. VERIFY PWD - Confirm in correct directory",
      "3. SAVE STATE - Update working_memory.json and step_progress_tracker.json",
      "4. RELOAD - Read workflow file, architectural_definitions.json, templates",
      "5. READ - current_focus.md and step_progress_tracker.json",
      "6. CONFIRM - State system name, workflow, step, next action",
      "7. RESET - Set operations_since_refresh = 0",
      "8. RESUME - Continue with confirmed action"
    ],
    "pre_operation_checklist": [
      "Verify pwd equals system_root",
      "Read current_focus.md",
      "Read step_progress_tracker.json",
      "Verify action matches current step",
      "Check operations_since_refresh <= 4",
      "Verify not about to generate report/summary (do real work)"
    ]
  },
  "self_improvement": {
    "description": "Continuous workflow improvement through observation and metrics",
    "template_reference": "See templates/self_improvement_template.json for complete details",
    "during_execution": {
      "observe": ["Time efficiency", "Error patterns", "Quality gate effectiveness", "Tool performance", "Architecture validation issues"],
      "document": "Log observations to context/process_log.md with timestamps",
      "track_metrics": "Update context/workflow_metrics.json after each step"
    },
    "after_completion": {
      "retrospective_file": "context/workflow_retrospective_01-systems_engineering_{date}.md",
      "key_questions": [
        "What worked well?",
        "What architecture decisions were difficult?",
        "Which validation gave false positives/negatives?",
        "What took longer than expected?",
        "What could be automated?"
      ],
      "improvement_submission": "Add entries to WORKFLOW_IMPROVEMENTS_BACKLOG.md"
    }
  },
  "workflow_steps": [
    {
      "step_id": "SE-00",
      "name": "Auto-Detect Integration Approach",
      "description": "Automatically detect bottom-up (existing components) vs top-down (greenfield) by examining system directory",
      "phase": "approach_detection",
      "step_file": "workflow_steps/systems_engineering/SE-00-AutoDetectApproach.json",
      "approach": "auto_detect",
      "when_to_use": "When using 'auto' entry point - LLM examines system directory to determine approach",
      "actions": [
        {
          "action_id": "SE-00-A01",
          "description": "Examine system directory structure for existing components"
        },
        {
          "action_id": "SE-00-A02",
          "description": "Classify system as bottom-up or top-down based on evidence"
        },
        {
          "action_id": "SE-00-A03",
          "description": "Record detection result in approach_detection_result.json"
        },
        {
          "action_id": "SE-00-A04",
          "description": "Update working_memory.json with detected approach"
        },
        {
          "action_id": "SE-00-A05",
          "description": "Route to BU-01 (bottom-up) or SE-01 (top-down)"
        }
      ],
      "outputs": [
        "context/approach_detection_result.json",
        "context/working_memory.json (updated with detected_approach)"
      ],
      "next_step": "BU-01",
      "next_step_note": "Dynamic routing: BU-01 if bottom_up detected, SE-01 if top_down detected"
    },
    {
      "step_id": "BU-01",
      "name": "Component Inventory & Discovery (BOTTOM-UP)",
      "description": "Catalog all existing components for bottom-up integration",
      "phase": "bottom_up_analysis",
      "step_file": "workflow_steps/bottom_up_integration/BU-01-ComponentInventory.json",
      "approach": "bottom_up",
      "actions": [
        {
          "action_id": "BU-01-A01",
          "description": "Gather component list and source locations"
        },
        {
          "action_id": "BU-01-A02",
          "description": "Classify components by hierarchical tier"
        },
        {
          "action_id": "BU-01-A03",
          "description": "Analyze component capabilities"
        },
        {
          "action_id": "BU-01-A04",
          "description": "Extract exposed interfaces"
        },
        {
          "action_id": "BU-01-A05",
          "description": "Identify dependencies"
        },
        {
          "action_id": "BU-01-A06",
          "description": "Assess integration readiness"
        },
        {
          "action_id": "BU-01-A07",
          "description": "Create component_inventory.json"
        }
      ],
      "tools_used": [],
      "templates_used": ["component_inventory_template.json"],
      "outputs": ["specs/machine/component_inventory.json", "docs/COMPONENT_INVENTORY_SUMMARY.md"],
      "gates": [],
      "next_step": "BU-02"
    },
    {
      "step_id": "BU-02",
      "name": "Integration Requirements Definition (BOTTOM-UP)",
      "description": "Define how components should work together",
      "phase": "bottom_up_analysis",
      "step_file": "workflow_steps/bottom_up_integration/BU-02-IntegrationRequirements.json",
      "approach": "bottom_up",
      "actions": [
        {
          "action_id": "BU-02-A01",
          "description": "Define integration goal"
        },
        {
          "action_id": "BU-02-A02",
          "description": "Identify target capabilities"
        },
        {
          "action_id": "BU-02-A03",
          "description": "Map components to capabilities"
        },
        {
          "action_id": "BU-02-A04",
          "description": "Define required interactions"
        },
        {
          "action_id": "BU-02-A05",
          "description": "Specify non-functional requirements"
        },
        {
          "action_id": "BU-02-A06",
          "description": "Define success criteria"
        },
        {
          "action_id": "BU-02-A07",
          "description": "Create integration_requirements.json"
        }
      ],
      "tools_used": [],
      "templates_used": ["integration_requirements_template.json"],
      "outputs": ["specs/machine/integration_requirements.json"],
      "gates": [],
      "next_step": "BU-03"
    },
    {
      "step_id": "BU-03",
      "name": "Integration Gap Analysis (BOTTOM-UP)",
      "description": "Identify integration gaps preventing components from working together",
      "phase": "bottom_up_analysis",
      "step_file": "workflow_steps/bottom_up_integration/BU-03-IntegrationGapAnalysis.json",
      "approach": "bottom_up",
      "actions": [
        {
          "action_id": "BU-03-A01",
          "description": "Run analyze_integration_gaps.py tool",
          "tool": "analyze_integration_gaps.py"
        },
        {
          "action_id": "BU-03-A02",
          "description": "Review and classify gaps by severity"
        },
        {
          "action_id": "BU-03-A03",
          "description": "Recommend solutions for each gap"
        },
        {
          "action_id": "BU-03-A04",
          "description": "Create resolution roadmap"
        },
        {
          "action_id": "BU-03-A05",
          "description": "Finalize integration_gaps.json"
        }
      ],
      "tools_used": ["analyze_integration_gaps.py"],
      "templates_used": ["integration_gaps_template.json"],
      "outputs": ["specs/machine/integration_gaps.json"],
      "gates": [],
      "next_step": "BU-04"
    },
    {
      "step_id": "BU-04",
      "name": "Component Delta Analysis (BOTTOM-UP) - CRITICAL",
      "description": "Generate EXACT component-level changes (function/class/module level) required for integration",
      "phase": "bottom_up_analysis",
      "step_file": "workflow_steps/bottom_up_integration/BU-04-ComponentDeltaAnalysis.json",
      "approach": "bottom_up",
      "actions": [
        {
          "action_id": "BU-04-A01",
          "description": "Run generate_component_deltas.py for each component",
          "tool": "generate_component_deltas.py",
          "critical": true,
          "note": "Generates exact code changes: new_function, modify_function, new_module, etc."
        },
        {
          "action_id": "BU-04-A02",
          "description": "Review delta feasibility"
        },
        {
          "action_id": "BU-04-A03",
          "description": "Validate component deltas",
          "tool": "validate_component_deltas.py"
        },
        {
          "action_id": "BU-04-A04",
          "description": "Prioritize component deltas"
        },
        {
          "action_id": "BU-04-A05",
          "description": "Generate delta summary report"
        }
      ],
      "tools_used": ["generate_component_deltas.py", "validate_component_deltas.py"],
      "templates_used": ["component_delta_template.json"],
      "outputs": ["specs/machine/component_deltas/{component_id}_delta.json", "docs/COMPONENT_DELTAS_SUMMARY.md"],
      "gates": [],
      "next_step": "BU-05"
    },
    {
      "step_id": "BU-05",
      "name": "Integration Architecture Design (BOTTOM-UP)",
      "description": "Design multi-tier architecture showing component integration with adapters/mediators",
      "phase": "bottom_up_architecture",
      "step_file": "workflow_steps/bottom_up_integration/BU-05-IntegrationArchitectureDesign.json",
      "approach": "bottom_up",
      "actions": [
        {
          "action_id": "BU-05-A01",
          "description": "Create tier hierarchy"
        },
        {
          "action_id": "BU-05-A02",
          "description": "Design adapter components"
        },
        {
          "action_id": "BU-05-A03",
          "description": "Design mediator components"
        },
        {
          "action_id": "BU-05-A04",
          "description": "Create nested architecture files for each tier",
          "template": "component_architecture_nested_template.json"
        },
        {
          "action_id": "BU-05-A05",
          "description": "Define tier-crossing interfaces"
        },
        {
          "action_id": "BU-05-A06",
          "description": "Create interface_registry.json"
        },
        {
          "action_id": "BU-05-A07",
          "description": "Link deltas to architecture files"
        }
      ],
      "tools_used": [],
      "templates_used": ["component_architecture_nested_template.json", "interface_registry_enhanced_template.json"],
      "outputs": [
        "specs/machine/system_architecture.json",
        "specs/machine/systems/*/services/*/component_architecture.json",
        "specs/machine/interface_registry.json"
      ],
      "gates": [],
      "next_step": "BU-06"
    },
    {
      "step_id": "BU-06",
      "name": "Validation & Verification (BOTTOM-UP)",
      "description": "Validate bottom-up integration architecture and generate system graph",
      "phase": "bottom_up_validation",
      "step_file": "workflow_steps/bottom_up_integration/BU-06-ValidationVerification.json",
      "approach": "bottom_up",
      "actions": [
        {
          "action_id": "BU-06-A01",
          "description": "Validate architecture files",
          "tool": "validate_architecture.py --validate-nested"
        },
        {
          "action_id": "BU-06-A02",
          "description": "Create index.json"
        },
        {
          "action_id": "BU-06-A03",
          "description": "Generate system of systems graph",
          "tool": "system_of_systems_graph_v2.py --nested-tiers"
        },
        {
          "action_id": "BU-06-A04",
          "description": "Validate component deltas",
          "tool": "validate_component_deltas.py"
        },
        {
          "action_id": "BU-06-A05",
          "description": "Check for circular dependencies"
        },
        {
          "action_id": "BU-06-A06",
          "description": "Verify interface consistency"
        },
        {
          "action_id": "BU-06-A07",
          "description": "Generate integration validation report"
        }
      ],
      "tools_used": ["validate_architecture.py", "system_of_systems_graph_v2.py", "validate_component_deltas.py"],
      "outputs": [
        "specs/machine/index.json",
        "specs/machine/graphs/system_of_systems_graph.json",
        "docs/INTEGRATION_VALIDATION_REPORT.md"
      ],
      "gates": [
        {
          "gate_id": "G-BU-06",
          "name": "Bottom-Up Integration Validation Gate",
          "checks": [
            "All architecture files pass validation",
            "System graph shows coherent integration",
            "No critical integration gaps remain unresolved",
            "Component deltas are feasible",
            "Integration readiness = high"
          ],
          "blocking": true
        }
      ],
      "next_step": "SE-02",
      "transition_note": "Bottom-up workflow merges with top-down workflow at SE-02. Architecture files created, can proceed to further refinement or development."
    },
    {
      "step_id": "SE-01",
      "name": "System Analysis & Service Decomposition",
      "description": "Analyze system requirements and decompose into services",
      "phase": "analysis",
      "step_file": "workflow_steps/systems_engineering/SE-01-AnalysisAndDecomposition.json",
      "maps_from": "Arch-02: Analysis and Decomposition",
      "actions": [
        {
          "action_id": "SE-01-A01",
          "description": "Run feature analysis",
          "tool": "analyze_features.py",
          "command_pattern": "python3 {reflow_root}/tools/analyze_features.py {system_root}",
          "purpose": "Parse feature requirements and identify required systems/services",
          "inputs": ["docs/SYSTEM_MISSION_STATEMENT.md", "docs/USER_SCENARIOS.md"],
          "outputs": ["Initial service breakdown"]
        },
        {
          "action_id": "SE-01-A02",
          "description": "Classify system hierarchy",
          "purpose": "Determine if this is a single service, multi-service system, or system-of-systems",
          "decision_point": "Single service vs multi-service decomposition",
          "outputs": ["System hierarchy classification"]
        },
        {
          "action_id": "SE-01-A03",
          "description": "Decompose into services",
          "purpose": "Break down system into logical services based on business capabilities",
          "guidance": [
            "Follow domain-driven design principles",
            "Identify bounded contexts",
            "Define service responsibilities",
            "Ensure services are cohesive and loosely coupled"
          ],
          "outputs": ["List of services with responsibilities"]
        },
        {
          "action_id": "SE-01-A04",
          "description": "Create system decomposition document",
          "template": "system_decomposition_template.json",
          "location": "specs/machine/system_decomposition.json",
          "contains": [
            "Service list with descriptions",
            "Service boundaries",
            "Initial interface requirements",
            "Data ownership"
          ]
        }
      ],
      "tools_used": ["analyze_features.py"],
      "templates_used": ["system_decomposition_template.json"],
      "outputs": ["specs/machine/system_decomposition.json"],
      "gates": [],
      "next_step": "SE-02"
    },
    {
      "step_id": "SE-02",
      "name": "Service Architecture Specification",
      "description": "Create versioned service_architecture.json for each service with comprehensive UAF specifications",
      "phase": "architecture",
      "step_file": "workflow_steps/systems_engineering/SE-02-ServiceArchitecture.json",
      "maps_from": "Arch-02, Arch-03: Service architecture creation and validation",
      "note": "See step_file for complete specifications of all 8 actions (A01-A08)",
      "actions": [
        {
          "action_id": "SE-02-A01",
          "description": "Create versioned service_architecture.json with semantic versioning and symlinks",
          "template": "service_architecture_template.json",
          "output_pattern": "specs/machine/service_arch/{service}/service_architecture_v{semver}-{date}.json"
        },
        {
          "action_id": "SE-02-A02",
          "description": "Define component specifications for internal service components",
          "template": "component_specification_complete_template.json"
        },
        {
          "action_id": "SE-02-A02B",
          "description": "Plan edge weights if framework requires flow analysis (CONDITIONAL)",
          "condition": "Frameworks requiring edge weights: decision_flow, ecological (see step_file)"
        },
        {
          "action_id": "SE-02-A03",
          "description": "Define interface registry cataloging all service interfaces",
          "template": "interface_registry_enhanced_template.json",
          "output": "specs/machine/interface_registry.json"
        },
        {
          "action_id": "SE-02-A04",
          "description": "Assign ports and create port registry (CONDITIONAL - UAF/IT systems only)",
          "template": "port_registry_template.json",
          "output": "specs/machine/port_registry.json",
          "condition": "Only for frameworks with network services (UAF)"
        },
        {
          "action_id": "SE-02-A05",
          "description": "Create security architecture (CONDITIONAL - UAF with human users/external APIs)",
          "template": "security_architecture_template.json",
          "output": "specs/machine/security_architecture.json",
          "condition": "Required for systems with human users or external API access"
        },
        {
          "action_id": "SE-02-A06",
          "description": "Create deployment architecture (CONDITIONAL - UAF/IT systems)",
          "template": "deployment_architecture_template.json",
          "output": "specs/machine/deployment_architecture.json",
          "condition": "Required for IT systems requiring deployment infrastructure"
        },
        {
          "action_id": "SE-02-A07",
          "description": "Create UX and API design architecture (CONDITIONAL - UAF with users/APIs)",
          "template": "ux_api_design_template.json",
          "output": "specs/machine/ux_api_design.json",
          "condition": "Required for systems with human users or external API consumers"
        },
        {
          "action_id": "SE-02-A08",
          "description": "Design operational environment (CONDITIONAL - UAF production systems)",
          "template": "operational_environment_template.json",
          "output": "specs/machine/operational_environment.json",
          "condition": "Required for systems going to production - defines operational conditions and testing strategy"
        },
        {
          "action_id": "SE-02-A09",
          "description": "Define operational testing objectives for each service",
          "template": "operational_testing_objectives_template.json",
          "output": "specs/machine/service_arch/{service}/operational_testing_objectives.json",
          "new_in_version": "v3.6.0 - Early Testing Integration"
        },
        {
          "action_id": "SE-02-A10",
          "description": "Perform risk assessment for each service to guide testing thoroughness",
          "template": "service_risk_assessment_template.json",
          "output": "specs/machine/service_arch/{service}/risk_assessment.json",
          "new_in_version": "v3.6.0 - Early Testing Integration"
        }
      ],
      "tools_used": ["validate_port_registry.py"],
      "templates_used": [
        "service_architecture_template.json",
        "component_specification_complete_template.json",
        "interface_registry_enhanced_template.json",
        "port_registry_template.json",
        "security_architecture_template.json",
        "deployment_architecture_template.json",
        "ux_api_design_template.json",
        "operational_environment_template.json",
        "operational_testing_objectives_template.json",
        "service_risk_assessment_template.json"
      ],
      "outputs": [
        "specs/machine/service_arch/{service}/service_architecture_v{semver}-{date}.json (per service)",
        "specs/machine/interface_registry.json",
        "specs/machine/port_registry.json (if UAF/IT)",
        "specs/machine/security_architecture.json (if UAF with users)",
        "specs/machine/deployment_architecture.json (if UAF/IT)",
        "specs/machine/ux_api_design.json (if UAF with users/APIs)",
        "specs/machine/operational_environment.json (if UAF production)",
        "specs/machine/service_arch/{service}/operational_testing_objectives.json (NEW v3.6.0)",
        "specs/machine/service_arch/{service}/risk_assessment.json (NEW v3.6.0)"
      ],
      "gates": [],
      "next_step": "SE-03"
    },
    {
      "step_id": "SE-03",
      "name": "Constraints & Template Validation",
      "description": "Validate all service architectures against templates and constraints",
      "phase": "validation",
      "step_file": "workflow_steps/systems_engineering/SE-03-ConstraintsValidation.json",
      "maps_from": "Arch-03: Constraints and Template Validation",
      "actions": [
        {
          "action_id": "SE-03-A01",
          "description": "Run architecture validation for each service",
          "tool": "validate_architecture.py",
          "command_pattern": "python3 {reflow_root}/tools/validate_architecture.py {system_root} --service {service_name}",
          "purpose": "Ensure service_architecture.json complies with template",
          "validation_checks": [
            "All required sections present",
            "UAF 1.2 compliance",
            "JSON schema validation",
            "Referential integrity"
          ]
        },
        {
          "action_id": "SE-03-A02",
          "description": "Validate constraints",
          "checks": [
            "Technical constraints (language, frameworks, libraries)",
            "Deployment constraints (cloud provider, container orchestration)",
            "Security constraints (authentication, authorization, encryption)",
            "Performance constraints (latency, throughput, scalability)"
          ]
        },
        {
          "action_id": "SE-03-A03",
          "description": "Issue Resolution Loop - Fix validation errors iteratively",
          "pattern": "MANDATORY LOOP - Do not skip this",
          "loop_structure": {
            "step_1": "Run validate_architecture.py for service",
            "step_2": "Capture and analyze ALL errors and warnings from tool output",
            "step_3": "Categorize issues (missing sections, type errors, UAF violations, referential integrity)",
            "step_4": "Fix issues by category (see common_issues below)",
            "step_5": "Re-run validate_architecture.py on same service",
            "step_6": "If errors remain, LOOP back to step_2",
            "step_7": "If validation passes (zero errors), move to next service",
            "termination": "Loop continues until zero errors OR max 5 iterations (then escalate to user)"
          },
          "common_issues_and_fixes": [
            {
              "issue": "Missing required section (e.g., data_models, deployment_architecture)",
              "fix": "Add section from template, populate with service-specific content",
              "tool_reference": "Check templates/service_architecture_template.json for required structure"
            },
            {
              "issue": "Invalid JSON structure or syntax",
              "fix": "Fix JSON syntax errors, ensure valid brackets/braces/commas",
              "verification": "Use JSON validator before re-running architecture validation"
            },
            {
              "issue": "UAF 1.2 compliance violation",
              "fix": "Review definitions/architectural_definitions.json for UAF requirements, update architecture accordingly",
              "examples": "Wrong classification, missing mandatory fields, incorrect nesting"
            },
            {
              "issue": "Referential integrity error (interface not found in registry)",
              "fix": "Either add missing interface to interface_registry.json OR correct interface reference in service_architecture.json",
              "cross_check": "Verify interface exists in specs/machine/interface_registry.json"
            },
            {
              "issue": "Type mismatch (field expects array but got string)",
              "fix": "Correct field type to match template schema",
              "tool_reference": "Check template for correct types"
            },
            {
              "issue": "Empty or placeholder values in required fields",
              "fix": "Replace placeholders with actual architectural decisions",
              "examples": "REPLACE_WITH_X, TBD, TODO must be replaced with real values"
            }
          ],
          "llm_agent_instructions": [
            "DO NOT proceed to next service until current service passes validation",
            "DO NOT skip errors - every error must be fixed",
            "DO NOT assume validation passes - always check tool output",
            "READ the actual error messages from validate_architecture.py carefully",
            "If same error appears 3+ times, re-read template and definitions to understand requirement",
            "Track iteration count - if exceeding 5 iterations, review your approach"
          ],
          "success_criteria": "validate_architecture.py returns zero errors for the service"
        },
        {
          "action_id": "SE-03-A04",
          "description": "Validate port registry for conflicts (CONDITIONAL - only if port_registry.json exists)",
          "condition": {
            "check": "framework_registry.json -> frameworks[framework_id].deployment_characteristics.port_management_applicable == true",
            "if_true": "Validate port_registry.json for conflicts",
            "if_false": "Skip this action - port registry not applicable for non-IT systems",
            "note": "This action only runs if SE-02-A04 was executed (i.e., port_registry.json exists)"
          },
          "tool": "validate_port_registry.py",
          "command_pattern": "python3 {reflow_root}/tools/validate_port_registry.py {system_root}/specs/machine/port_registry.json",
          "purpose": "Ensure no port conflicts exist before development begins (IT systems only)",
          "validation_checks": [
            "PC-01: No duplicate primary ports across services",
            "PC-02: No port overlap between any service ports (primary, metrics, admin)",
            "PC-03: Ports within designated ranges (app:8000-8099, internal:8100-8199, etc.)",
            "PC-04: Avoid privileged ports below 1024",
            "PC-05: Docker host-container port mapping consistency"
          ],
          "common_port_conflicts": {
            "duplicate_primary_ports": {
              "symptom": "Two services assigned same primary port (e.g., both on 8000)",
              "fix": "Reassign second service to next available port in range",
              "prevention": "Use sequential allocation within ranges"
            },
            "metrics_conflicts_with_primary": {
              "symptom": "Service A metrics port (9001) conflicts with Service B primary (9001)",
              "fix": "Shift metrics ports to separate range or use primary+1000 pattern",
              "prevention": "Standardize metrics port allocation pattern"
            },
            "well_known_port_conflicts": {
              "symptom": "Service assigned port 5432 conflicts with PostgreSQL",
              "fix": "Check third_party_defaults in port_ranges, avoid those ports",
              "prevention": "Reserve well-known ports for their intended services"
            }
          },
          "success_criteria": "validate_port_registry.py returns zero errors",
          "blocking": "Yes - port conflicts MUST be resolved before development",
          "rationale": "Catching port conflicts now prevents 'Address already in use' errors during deployment and testing phases"
        },
        {
          "action_id": "SE-03-A05",
          "description": "Validate security architecture (CONDITIONAL - if security_architecture.json exists)",
          "condition": {
            "check": "security_architecture.json exists in specs/machine/",
            "if_true": "Validate security architecture for completeness and best practices",
            "if_false": "Skip - security architecture not required for internal-only systems"
          },
          "validation_type": "Manual review + automated checks",
          "validation_checks": [
            "Authentication strategy defined and appropriate for user types",
            "Authorization model (RBAC/ABAC) complete with roles and permissions",
            "API gateway configuration includes SSL/TLS, CORS, rate limiting",
            "Rate limiting strategy defined with specific limits",
            "Input validation covers XSS and SQL injection prevention",
            "Encryption specified for both in-transit (TLS 1.2+) and at-rest (AES-256)",
            "Audit logging configured with retention policy and alerting",
            "Security testing approach defined (SAST, dependency scanning)"
          ],
          "common_issues": {
            "weak_authentication": {
              "symptom": "No MFA for privileged users, weak password policy",
              "fix": "Enable MFA for admin roles, enforce strong password requirements",
              "security_impact": "HIGH - weak auth leads to account compromise"
            },
            "missing_api_gateway": {
              "symptom": "Services exposed directly without gateway",
              "fix": "Add api_gateway service, route all external traffic through it",
              "security_impact": "CRITICAL - no centralized auth, rate limiting, or request validation"
            },
            "insufficient_rate_limiting": {
              "symptom": "No rate limits or very high limits",
              "fix": "Define reasonable per-user and per-IP limits (e.g., 100 req/min)",
              "security_impact": "MEDIUM - vulnerable to DoS and brute force attacks"
            },
            "no_encryption_at_rest": {
              "symptom": "Sensitive data stored in plaintext",
              "fix": "Identify sensitive fields (passwords, PII, tokens), encrypt with AES-256",
              "security_impact": "HIGH - data breach exposes sensitive information"
            }
          },
          "review_questions": [
            "Is the authentication flow simple enough for users to understand?",
            "Are error messages helpful without exposing security details?",
            "Is the security approach proportional to the threat model?",
            "Are there clear procedures for security incidents?",
            "Is secret management automated and secure?"
          ],
          "success_criteria": "Security architecture addresses all threat vectors, follows industry best practices, and provides positive UX",
          "blocking": "Yes - security gaps MUST be addressed before development",
          "rationale": "Security vulnerabilities discovered after implementation are 10x more expensive to fix than during design"
        },
        {
          "action_id": "SE-03-A06",
          "description": "Validate deployment architecture (CONDITIONAL - if deployment_architecture.json exists)",
          "condition": {
            "check": "deployment_architecture.json exists in specs/machine/",
            "if_true": "Validate deployment architecture for ease and completeness",
            "if_false": "Skip - deployment architecture not required for non-IT systems"
          },
          "validation_type": "Manual review + automated checks",
          "validation_checks": [
            "Deployment philosophy emphasizes simplicity and ease",
            "One-command deployment strategy defined (docker-compose up -d OR kubectl apply)",
            "Containerization with Docker/Podman using official base images",
            "Orchestration choice justified (docker-compose for simplicity OR kubernetes for scale)",
            "CI/CD pipeline defined with build, test, deploy stages",
            "Environment management covers dev, staging, production with parity",
            "Service discovery mechanism defined (DNS, health checks)",
            "Monitoring and observability strategy complete (metrics, logging, alerting)",
            "Backup and disaster recovery with defined RTO/RPO"
          ],
          "common_issues": {
            "overcomplicated_orchestration": {
              "symptom": "Using Kubernetes for 3-service system that doesn't need it",
              "fix": "Simplify to docker-compose unless scale/HA features truly needed",
              "impact": "Increases deployment complexity, slows iteration"
            },
            "no_health_checks": {
              "symptom": "Services don't expose /health or /ready endpoints",
              "fix": "Add health check endpoints to all services, configure in orchestrator",
              "impact": "Can't detect service failures, no automated recovery"
            },
            "manual_deployment_steps": {
              "symptom": "Deployment requires multiple manual commands or configuration",
              "fix": "Automate in single command or script, document in README",
              "impact": "Error-prone deployments, slow onboarding for new developers"
            },
            "no_rollback_strategy": {
              "symptom": "No defined procedure to revert failed deployments",
              "fix": "Define rollback command/procedure, test it works",
              "impact": "Failed deployments cause prolonged outages"
            },
            "missing_observability": {
              "symptom": "No metrics, logging, or alerting defined",
              "fix": "Add Prometheus metrics, centralized logging, critical alerts",
              "impact": "Can't diagnose issues, blind to system health"
            }
          },
          "review_questions": [
            "Can a new developer deploy the entire system in < 10 minutes?",
            "Is the deployment process documented step-by-step in README?",
            "Is rollback simple and fast (< 5 minutes)?",
            "Are health checks comprehensive enough to detect failures?",
            "Is the infrastructure reproducible (IaC) or manual?",
            "Are there clear procedures for scaling up/down?"
          ],
          "success_criteria": "Deployment is simple, automated, well-documented, and enables rapid iteration",
          "blocking": "Yes - complex or undocumented deployment will slow development and increase errors",
          "rationale": "Deployment ease directly impacts development velocity and system reliability"
        },
        {
          "action_id": "SE-03-A07",
          "description": "Validate UX and API design architecture (CONDITIONAL - if ux_api_design.json exists)",
          "condition": {
            "check": "ux_api_design.json exists in specs/machine/",
            "if_true": "Validate UX and API design for clarity, consistency, and developer-friendliness",
            "if_false": "Skip - UX/API design not required for internal machine-to-machine systems"
          },
          "validation_type": "Manual review + automated checks",
          "validation_checks": [
            "UX philosophy defined with clear user types and goals",
            "API design principles follow REST/GraphQL best practices",
            "API endpoints follow consistent naming and structure",
            "Error handling provides user-friendly messages with recovery guidance",
            "API documentation includes OpenAPI spec, interactive docs, code examples",
            "Versioning strategy defined (url_path recommended) with deprecation policy",
            "Performance targets set (p50, p95, p99 latency)",
            "Rate limiting transparent with clear headers and error messages",
            "Authentication UX is simple with clear token management",
            "API gateway defined with responsibilities (auth, rate limiting, routing)"
          ],
          "common_issues": {
            "inconsistent_api_design": {
              "symptom": "Some endpoints use camelCase, others snake_case; mixed naming conventions",
              "fix": "Standardize on single convention (snake_case recommended), document in API design",
              "impact": "Developer confusion, harder to use API"
            },
            "poor_error_messages": {
              "symptom": "Errors like '500 Internal Server Error' or technical jargon",
              "fix": "Return helpful messages: 'Email is required. Please provide your email address.'",
              "impact": "Users can't recover from errors, support burden increases"
            },
            "missing_api_documentation": {
              "symptom": "No OpenAPI spec, no interactive docs, no code examples",
              "fix": "Create OpenAPI 3.0 spec, generate Swagger UI docs, add curl/Python/JS examples",
              "impact": "Developers can't use API without extensive trial and error"
            },
            "no_api_gateway": {
              "symptom": "Services exposed directly, no unified entry point",
              "fix": "Add api_gateway service, route all traffic through single base URL",
              "impact": "Inconsistent auth, can't enforce rate limits, poor observability"
            },
            "api_gateway_not_implemented": {
              "symptom": "api_gateway defined in architecture but only scaffolding exists (orphaned service)",
              "fix": "Implement api_gateway with routing, auth, rate limiting, SSL termination",
              "impact": "CRITICAL - system non-functional without working gateway"
            },
            "unclear_versioning": {
              "symptom": "No versioning strategy or using query params/headers (hard to discover)",
              "fix": "Use url_path versioning (/api/v1/users) - most visible and explicit",
              "impact": "Breaking changes break all clients, no migration path"
            }
          },
          "review_questions": [
            "Can a developer make their first successful API call in < 5 minutes from reading docs?",
            "Are error messages helpful and actionable, not just technical failures?",
            "Is the API consistent and predictable across all endpoints?",
            "Does the system have a working API gateway (not just scaffolding)?",
            "Is API documentation complete with examples for common use cases?",
            "Can users easily obtain and manage API tokens/credentials?",
            "Are rate limits clearly communicated with headers and documentation?",
            "Is the UX simple enough for target user skill level?"
          ],
          "api_gateway_validation": {
            "critical": "If api_gateway service exists in architecture, validate it will be FULLY IMPLEMENTED, not orphaned",
            "check_in_SE_06": "system_of_systems_graph_v2.py with --analyze-issues will detect orphaned services",
            "prevention": "Mark api_gateway as critical path service, validate implementation in Development workflow"
          },
          "success_criteria": "UX and API design enables users to succeed quickly with minimal friction",
          "blocking": "Yes - poor UX/API design decisions are expensive to fix after launch",
          "rationale": "User experience determines adoption, retention, and competitive advantage"
        },
        {
          "action_id": "SE-03-A08",
          "description": "Validate operational environment design (CONDITIONAL - if operational_environment.json exists)",
          "condition": {
            "check": "operational_environment.json exists in specs/machine/",
            "if_true": "Validate operational environment addresses all 10 considerations and real-world conditions",
            "if_false": "Skip - operational environment not required for prototypes or non-IT systems"
          },
          "validation_type": "Manual review + checklist validation",
          "validation_checks_10_considerations": [
            {
              "check": "1. Service Decomposition & Boundaries",
              "validation": "Bounded contexts defined, single responsibility per service, data ownership clear (no shared databases), communication patterns chosen (sync vs async)"
            },
            {
              "check": "2. Containerization & Packaging",
              "validation": "Docker strategy defined, base images selected, multi-stage builds planned, orchestration choice justified (ECS vs EKS vs docker-compose)"
            },
            {
              "check": "3. Infrastructure as Code & Automation",
              "validation": "Ansible playbooks planned (deploy, rollback, provision), environment separation defined (dev/staging/prod), dynamic inventory configured"
            },
            {
              "check": "4. CI/CD Pipeline Integration",
              "validation": "Git workflow defined, pipeline stages clear (build, test, deploy), automated testing strategy complete, versioning scheme chosen"
            },
            {
              "check": "5. Scalability & Resilience",
              "validation": "Horizontal scaling strategy defined, fault tolerance patterns chosen (circuit breakers, retries, timeouts), state management clear (stateless vs stateful)"
            },
            {
              "check": "6. Security & Compliance",
              "validation": "IAM roles defined, secrets management strategy clear, VPC design complete, encryption specified (TLS, KMS), compliance requirements addressed"
            },
            {
              "check": "7. Monitoring, Logging, Observability",
              "validation": "Metrics defined (/metrics endpoint), logging strategy clear (JSON, correlation IDs), alerting configured (critical vs warning), dashboards planned"
            },
            {
              "check": "8. Service Discovery & Networking",
              "validation": "Discovery mechanism chosen (Cloud Map, Consul, K8s DNS), API Gateway defined, latency optimization considered"
            },
            {
              "check": "9. Cost Management & Optimization",
              "validation": "Resource sizing estimated, cost optimization strategies defined (spot instances, reserved instances, auto-scaling), tagging strategy clear"
            },
            {
              "check": "10. Testing & Rollback Strategies",
              "validation": "Test types defined (unit, integration, performance, security, chaos, operational), rollback procedures documented, backup/DR strategy clear"
            }
          ],
          "operational_environment_conditions_validation": {
            "real_world_failures_addressed": [
              "Network failures and partitions → circuit breakers, timeouts, retries",
              "Resource exhaustion → resource limits, graceful degradation, monitoring",
              "Cascading failures → bulkheads, fail-fast, rate limiting",
              "Traffic spikes → auto-scaling, queuing, caching",
              "Security attacks → WAF, rate limiting, input validation, audit logging",
              "Data corruption → validation, checksums, backup/restore",
              "Third-party outages → fallbacks, circuit breakers, cached responses",
              "Configuration drift → IaC, validation, immutable infrastructure"
            ],
            "test_plan_completeness": "Chaos engineering, load testing, fault injection, penetration testing planned with success criteria"
          },
          "testing_phase_relationship_validation": {
            "critical_check": "Operational environment defines WHICH tests to run and WHY. Testing phase (workflow 04) executes these tests - it doesn't invent new ones.",
            "validation_questions": [
              "Are test types clearly defined (unit, integration, performance, security, chaos, operational)?",
              "Are success criteria established for each test type?",
              "Are operational test scenarios defined (multi-AZ failover, database failover, auto-scaling, backup/restore)?",
              "Is it clear that testing phase executes this plan, not creates a new one?"
            ]
          },
          "common_issues": {
            "missing_consideration": {
              "symptom": "One or more of the 10 considerations not addressed",
              "fix": "Complete all 10 sections in operational_environment.json",
              "impact": "Incomplete operational design leads to production issues and emergency fixes"
            },
            "vague_strategies": {
              "symptom": "Strategies described generically without specific choices (e.g., 'we'll use monitoring' without defining metrics)",
              "fix": "Make concrete decisions: specific tools, specific metrics, specific thresholds",
              "impact": "Vague designs lead to implementation inconsistencies and rework"
            },
            "ideal_conditions_only": {
              "symptom": "Design assumes perfect conditions, doesn't address failures",
              "fix": "Define operational_environment_conditions with real failure scenarios and design responses",
              "impact": "System fails in production under real-world stress"
            },
            "testing_strategy_missing": {
              "symptom": "No clear definition of which tests to run or success criteria",
              "fix": "Complete testing_rollback_strategies section with specific test types and criteria",
              "impact": "Testing phase doesn't know what to validate, important scenarios missed"
            },
            "deferred_decisions": {
              "symptom": "Critical decisions marked as 'TBD' or 'will decide later'",
              "fix": "Make architectural decisions NOW - deferring to testing/operations is too late",
              "impact": "Budget overages and costly program delays from retrofitting production-readiness"
            }
          },
          "review_questions": [
            "Does operational environment address ALL 10 considerations (service decomposition, containerization, IaC, CI/CD, scalability, security, monitoring, networking, cost, testing)?",
            "Are real-world failure conditions (not ideal conditions) explicitly designed for?",
            "Is it clear which tests will run in testing phase and why?",
            "Are success criteria established for operational readiness?",
            "Have concrete technology choices been made (not just 'we'll use monitoring')?",
            "Is the relationship between SE phase (design) and testing phase (execute) clear?",
            "Does design focus on scalability, reliability, security, maintainability for production?"
          ],
          "success_criteria": "Operational environment comprehensively addresses all 10 considerations, designs for real-world failures, defines complete testing strategy with success criteria",
          "blocking": "Yes - incomplete operational environment leads to production issues, budget overages, and program delays",
          "rationale": "Operational environment is architectural decision made NOW. NOT considering it upfront causes 10-100x cost increase to retrofit."
        }
      ],
      "tools_used": ["validate_architecture.py", "validate_port_registry.py"],
      "outputs": ["Validation reports", "Corrected service_architecture.json files", "Validated port_registry.json", "Validated security_architecture.json", "Validated deployment_architecture.json", "Validated ux_api_design.json", "Validated operational_environment.json"],
      "gates": [
        {
          "gate_id": "G-SE-03",
          "name": "Architecture Validation Gate",
          "checks": [
            "All architecture files pass validation",
            "Zero validation errors",
            "All required sections populated",
            "Interface registry complete",
            "Port registry validated with zero port conflicts (if applicable to framework)",
            "Security architecture validated (if UAF with human users) - BLOCKING",
            "Deployment architecture validated (if UAF/IT system) - BLOCKING",
            "UX and API design validated (if UAF with human users/external APIs) - BLOCKING",
            "Operational environment validated (if UAF going to production) - BLOCKING - addresses all 10 considerations and real-world failures"
          ],
          "conditional_checks": {
            "port_registry_validation": "Only required if deployment_characteristics.port_management_applicable == true (i.e., UAF framework)",
            "security_architecture_validation": "Required if framework_id == 'uaf' AND (human users OR external APIs)",
            "deployment_architecture_validation": "Required if framework_id == 'uaf' AND deployment_characteristics.port_management_applicable == true",
            "ux_api_design_validation": "Required if framework_id == 'uaf' AND (human users OR external APIs)",
            "operational_environment_validation": "Required if framework_id == 'uaf' AND system going to production (NOT for prototypes)"
          },
          "upfront_emphasis_gate": {
            "purpose": "Enforce that security, deployment ease, UX, AND operational environment are designed UPFRONT, not as afterthoughts",
            "blocking_rationale": "IT systems in modern, interconnected world MUST be designed for REAL operational conditions from the start. Systems don't operate in benign, vacuum environments.",
            "modern_world_requirements": [
              "Security: Authentication, authorization, encryption, audit logging designed before any code written",
              "Deployment: One-command deployment, automated rollback, comprehensive monitoring designed before development",
              "UX: Intuitive APIs, clear errors, comprehensive docs designed before implementation",
              "API Gateway: If human users/external APIs, gateway MUST exist and be fully implemented (not orphaned)",
              "Operational Environment: Design for failures, attacks, load spikes, network issues UPFRONT. Define which tests to run and why during SE phase."
            ],
            "systems_engineering_vs_testing_phase": {
              "se_phase": "Design for real operational environment, define which tests needed, establish success criteria, make architectural decisions",
              "testing_phase": "Execute tests planned during SE phase, validate system survives operational conditions, measure against baselines",
              "critical_distinction": "Testing phase does NOT define new tests - those are architectural decisions made NOW during SE phase"
            },
            "cost_of_retrofitting": "NOT considering operational environment upfront causes budget overages and costly program delays. Retrofitting production-readiness is 10-100x more expensive than designing for it.",
            "real_world_conditions": "Systems face network failures, resource exhaustion, cascading failures, traffic spikes, security attacks, data corruption, third-party outages, config drift. Design for these NOW, not hope they don't happen."
          },
          "blocking": true
        }
      ],
      "next_step": "SE-04"
    },
    {
      "step_id": "SE-04",
      "name": "Deployment Architecture Reconciliation",
      "description": "Reconcile logical architecture with deployment architecture",
      "phase": "architecture",
      "step_file": "workflow_steps/systems_engineering/SE-04-DeploymentArchitecture.json",
      "maps_from": "Arch-04: Deployment and Deep Dive",
      "actions": [
        {
          "action_id": "SE-04-A01",
          "description": "Define deployment environment",
          "considerations": [
            "Cloud provider (AWS, Azure, GCP, on-premises)",
            "Container orchestration (Kubernetes, Docker Swarm, ECS)",
            "Networking (VPC, subnets, load balancers)",
            "Storage (databases, object storage, caching)"
          ],
          "updates": "deployment_architecture section in service_architecture.json"
        },
        {
          "action_id": "SE-04-A02",
          "description": "Map logical components to deployment units",
          "purpose": "Determine how logical services map to containers, VMs, serverless functions",
          "output": "Deployment mapping in service_architecture.json"
        },
        {
          "action_id": "SE-04-A03",
          "description": "Define infrastructure requirements",
          "includes": [
            "Compute resources (CPU, memory)",
            "Storage resources (disk, IOPS)",
            "Network resources (bandwidth, connections)",
            "Scaling policies (auto-scaling, manual scaling)"
          ]
        },
        {
          "action_id": "SE-04-A04",
          "description": "Update service_architecture.json with deployment details",
          "purpose": "Ensure deployment_architecture section is complete and consistent with logical architecture"
        }
      ],
      "tools_used": [],
      "outputs": ["Updated service_architecture.json with deployment details"],
      "gates": [],
      "next_step": "SE-05"
    },
    {
      "step_id": "SE-05",
      "name": "Consistency & Specification Verification",
      "description": "Ensure all specifications are consistent and complete",
      "phase": "verification",
      "step_file": "workflow_steps/systems_engineering/SE-05-ConsistencyVerification.json",
      "maps_from": "Arch-05: Consistency and Specification Verification",
      "actions": [
        {
          "action_id": "SE-05-A01",
          "description": "Cross-service interface consistency check",
          "purpose": "Ensure interfaces between services are consistently defined on both sides",
          "checks": [
            "Producer-consumer interface agreements",
            "Data contract consistency",
            "Protocol compatibility",
            "Version compatibility"
          ]
        },
        {
          "action_id": "SE-05-A02",
          "description": "Validate foundational alignment",
          "tool": "validate_foundational_alignment.py",
          "command_pattern": "python3 {reflow_root}/tools/validate_foundational_alignment.py {system_root}",
          "purpose": "Ensure architecture aligns with foundational documents",
          "checks": [
            "All user scenarios covered by architecture",
            "Success criteria addressable by architecture",
            "Mission statement reflected in design"
          ]
        },
        {
          "action_id": "SE-05-A03",
          "description": "Identify integration points",
          "tool": "identify_integration_points.py",
          "command_pattern": "python3 {reflow_root}/tools/identify_integration_points.py {system_root}",
          "purpose": "Detect potential architectural issues (circular dependencies, missing interfaces, etc.)"
        },
        {
          "action_id": "SE-05-A04",
          "description": "Specification completeness review",
          "checklist": [
            "All services have complete service_architecture.json",
            "All interfaces documented in interface_registry.json",
            "All components have specifications",
            "All data models defined",
            "All constraints captured"
          ]
        }
      ],
      "tools_used": [
        "validate_foundational_alignment.py",
        "identify_integration_points.py"
      ],
      "outputs": [
        "Consistency validation report",
        "Integration point analysis",
        "Foundational alignment report"
      ],
      "gates": [
        {
          "gate_id": "G-SE-05",
          "name": "Specification Completeness Gate",
          "checks": [
            "All specifications complete",
            "Cross-service consistency verified",
            "Foundational alignment validated",
            "No critical integration issues"
          ],
          "blocking": true
        }
      ],
      "next_step": "SE-06"
    },
    {
      "step_id": "SE-06",
      "name": "System Graph Generation",
      "description": "Generate system graph with framework-specific NetworkX analysis, knowledge gap detection, and architectural validation",
      "phase": "artifacts",
      "step_file": "workflow_steps/systems_engineering/SE-06-GraphGeneration.json",
      "maps_from": "Part of Arch-06, extracted for machine-readable artifacts",
      "note": "See step_file for complete specifications of all 4 actions (A01-A04) with comprehensive analysis guidance",
      "criticality": "CRITICAL - This is comprehensive architecture validation, not just graph generation",
      "actions": [
        {
          "action_id": "SE-06-A01",
          "description": "Create index.json catalog with symlinks to latest architecture versions",
          "template": "index_template.json",
          "output": "specs/machine/index.json"
        },
        {
          "action_id": "SE-06-A02",
          "description": "Generate and validate system_of_systems_graph.json with framework-specific NetworkX analysis",
          "tool": "system_of_systems_graph_v2.py",
          "criticality": "CRITICAL - Validates architecture quality, detects issues, requires framework-appropriate analysis selection",
          "note": "See step_file for: analysis selection guidance, validation loop, issue detection, LLM agent instructions"
        },
        {
          "action_id": "SE-06-A03",
          "description": "Create version_manifest.json tracking architecture version history",
          "template": "version_manifest_template.json",
          "output": "specs/machine/version_manifest.json"
        },
        {
          "action_id": "SE-06-A04",
          "description": "Finalize and verify all machine-readable architecture products",
          "verification": "All required files present and valid (index, graphs, version manifest)"
        },
        {
          "action_id": "SE-06-A05",
          "description": "Define comprehensive system test strategy based on complete architecture and risk assessments",
          "template": "system_test_strategy_template.json",
          "output": "specs/machine/system_test_strategy.json",
          "new_in_version": "v3.6.0 - Early Testing Integration"
        }
      ],
      "tools_used": ["system_of_systems_graph_v2.py"],
      "templates_used": ["index_template.json", "version_manifest_template.json", "system_test_strategy_template.json"],
      "outputs": [
        "specs/machine/index.json",
        "specs/machine/graphs/system_of_systems_graph.json",
        "specs/machine/architecture_issues.json",
        "specs/machine/version_manifest.json",
        "context/working_memory.json (updated with analysis_configuration)",
        "specs/machine/system_test_strategy.json (NEW v3.6.0)"
      ],
      "gates": [
        {
          "gate_id": "G-SE-06",
          "name": "Architecture Completion Gate",
          "checks": [
            "All machine-readable artifacts present",
            "system_of_systems_graph.json generated successfully with framework-appropriate analyses",
            "No CRITICAL architectural issues detected",
            "index.json catalogs all artifacts",
            "version_manifest.json tracks all service versions"
          ],
          "blocking": true
        }
      ],
      "next_step": "complete",
      "note": "For architecture updates, see SE-07 (optional); for mixed-version testing, see SE-08 (optional)"
    },
    {
      "step_id": "SE-07",
      "name": "Architecture Evolution (OPTIONAL - For Updates)",
      "description": "Update existing architecture with proper versioning",
      "phase": "evolution",
      "optional": true,
      "when_to_use": "When updating existing service architecture to new version",
      "step_file": "workflow_steps/systems_engineering/SE-07-ArchitectureEvolution.json",
      "actions": [
        {
          "action_id": "SE-07-A01",
          "description": "Determine appropriate version increment",
          "semantic_versioning_rules": {
            "major": "Breaking interface changes, fundamental architecture changes (v1.x.x → v2.0.0)",
            "minor": "New capabilities, non-breaking interface additions (v1.0.x → v1.1.0)",
            "patch": "Bug fixes, clarifications, documentation improvements (v1.0.0 → v1.0.1)"
          },
          "examples": {
            "major_change": "Changed authentication API from JWT to OAuth 2.0 (breaks clients)",
            "minor_change": "Added new optional API endpoint (backward compatible)",
            "patch_change": "Fixed typo in architecture description"
          },
          "output": "New version number: v{major}.{minor}.{patch}-{YYYYMMDD}"
        },
        {
          "action_id": "SE-07-A02",
          "description": "Create new versioned architecture file",
          "pattern": "service_architecture_v{new_version}-{YYYYMMDD}.json",
          "location": "specs/machine/service_arch/{service_name}/",
          "preservation_rule": "NEVER delete or overwrite old version - copy and modify",
          "command_example": "cp service_architecture_v1.0.0-20251024.json service_architecture_v2.0.0-20251030.json"
        },
        {
          "action_id": "SE-07-A03",
          "description": "Update architecture content in new version file",
          "purpose": "Make actual architecture changes in new versioned file",
          "note": "Old version remains unchanged for rollback and comparison"
        },
        {
          "action_id": "SE-07-A04",
          "description": "Update symlink to point to new version",
          "commands": [
            "cd specs/machine/service_arch/{service_name}",
            "rm service_architecture.json",
            "ln -s service_architecture_v{new_version}-{YYYYMMDD}.json service_architecture.json"
          ],
          "purpose": "Tools now automatically use new version via symlink"
        },
        {
          "action_id": "SE-07-A05",
          "description": "Update version_manifest.json",
          "actions": [
            "Add new version entry to versions array for this service",
            "Update latest_version field to point to new version",
            "Set change_type (major/minor/patch)",
            "Add description of what changed"
          ],
          "preservation": "Keep all old version entries - never delete history"
        },
        {
          "action_id": "SE-07-A06",
          "description": "Run validation on new version",
          "tool": "validate_architecture.py",
          "command": "python3 {reflow_root}/tools/validate_architecture.py {system_root}",
          "note": "Validates via symlink, so validates new version",
          "success_criteria": "All validations pass"
        },
        {
          "action_id": "SE-07-A07",
          "description": "Regenerate system_of_systems_graph.json",
          "tool": "system_of_systems_graph_v2.py",
          "command": "python3 {reflow_root}/tools/system_of_systems_graph_v2.py {system_root}",
          "note": "Uses symlinks from index.json, so automatically uses new version"
        },
        {
          "action_id": "SE-07-A08",
          "description": "Update human-readable documentation (if exists)",
          "note": "See artifacts workflow (AV-03-A02) for creating versioned system_description.md",
          "pairing_rule": "Human doc version must match architecture version"
        }
      ],
      "tools_used": ["validate_architecture.py", "system_of_systems_graph_v2.py"],
      "outputs": [
        "New versioned service_architecture.json file",
        "Updated symlink",
        "Updated version_manifest.json",
        "Regenerated system_of_systems_graph.json"
      ],
      "rollback_support": {
        "description": "Easy rollback to previous version if issues found",
        "procedure": [
          "Update symlink to point back to old version",
          "Update version_manifest.json latest_version field",
          "Regenerate system_of_systems_graph.json",
          "All historical versions preserved"
        ]
      },
      "gates": [],
      "next_step": "complete"
    },
    {
      "step_id": "SE-08",
      "name": "Mixed-Version Validation (OPTIONAL)",
      "description": "Test specific combinations of service versions",
      "phase": "validation",
      "optional": true,
      "when_to_use": "Testing partial upgrades, compatibility across versions, deployment scenarios",
      "step_file": "workflow_steps/systems_engineering/SE-08-MixedVersionValidation.json",
      "use_cases": [
        "Validate auth_service v2.0 works with api_gateway v1.0 before deploying",
        "Test compatibility of different service version combinations",
        "Create baseline snapshots for regression testing",
        "Document known-good version combinations"
      ],
      "actions": [
        {
          "action_id": "SE-08-A01",
          "description": "Create version-specific index file",
          "naming_convention": "index_v{scenario_description}-{YYYYMMDD}.json",
          "location": "specs/machine/index_v{scenario}-{date}.json",
          "example_filename": "index_v2.0-auth-v1.0-gateway-20251030.json",
          "content_structure": {
            "components": {
              "{service_name}": "specs/machine/service_arch/{service}/service_architecture_v{specific_version}-{date}.json"
            },
            "version_scenario": {
              "name": "Descriptive scenario name",
              "created_date": "YYYY-MM-DD",
              "purpose": "Why this version combination is being tested",
              "services_versions": {
                "{service_name}": "v{version}-{date}"
              }
            }
          },
          "note": "Points directly to specific versioned files (not symlinks)"
        },
        {
          "action_id": "SE-08-A02",
          "description": "Run validation on version-specific index",
          "tool": "validate_architecture.py",
          "command": "python3 {reflow_root}/tools/validate_architecture.py {system_root} --index specs/machine/index_v{scenario}-{date}.json",
          "purpose": "Validate this specific combination of service versions",
          "checks": [
            "Interface contract compatibility",
            "Breaking changes between versions",
            "Integration issues",
            "Dependency conflicts"
          ]
        },
        {
          "action_id": "SE-08-A03",
          "description": "Generate version-specific system graph",
          "tool": "system_of_systems_graph_v2.py",
          "command": "python3 {reflow_root}/tools/system_of_systems_graph_v2.py {system_root}/specs/machine/index_v{scenario}-{date}.json --output specs/machine/graphs/system_of_systems_graph_v{scenario}-{date}.json",
          "purpose": "Create graph showing this specific version combination",
          "output": "specs/machine/graphs/system_of_systems_graph_v{scenario}-{date}.json"
        },
        {
          "action_id": "SE-08-A04",
          "description": "Analyze compatibility issues",
          "analysis_areas": [
            "Interface mismatches between service versions",
            "Breaking changes causing integration failures",
            "Deprecated features still in use",
            "Version dependency conflicts"
          ],
          "output": "Compatibility analysis report"
        },
        {
          "action_id": "SE-08-A05",
          "description": "Document validation results",
          "location": "specs/human/reports/VERSION_COMPATIBILITY_v{scenario}-{date}.md",
          "includes": [
            "Version combination tested",
            "Validation results (pass/fail)",
            "Compatibility issues found",
            "Recommendations (safe to deploy / needs fixes)",
            "Rollback plan if deployed"
          ]
        },
        {
          "action_id": "SE-08-A06",
          "description": "Update version_manifest.json with new index and graph",
          "actions": [
            "Add entry to version_indexes array",
            "Add entry to system_graphs array",
            "Link index to corresponding graph"
          ],
          "purpose": "Track all tested version combinations"
        }
      ],
      "tools_used": ["validate_architecture.py", "system_of_systems_graph_v2.py"],
      "outputs": [
        "Version-specific index file",
        "Version-specific system graph",
        "Compatibility analysis report",
        "Updated version_manifest.json"
      ],
      "gates": [],
      "next_step": "complete"
    }
  ],
  "completion": {
    "description": "Systems engineering & architecture workflow complete - all machine-readable artifacts created",
    "outputs_summary": [
      "service_architecture.json for each service (UAF 1.2 compliant)",
      "system_of_systems_graph.json",
      "interface_registry.json",
      "index.json",
      "version_manifest.json",
      "All artifacts validated and consistent"
    ],
    "next_workflow": "02-artifacts_visualization",
    "transition_command": "workflow_driver.py {system_root} --next-workflow"
  },
  "llm_agent_guidance": {
    "critical_reminders": [
      "ALWAYS use absolute paths from working_memory.json for tool invocations",
      "Run validate_architecture.py after creating each service_architecture.json",
      "Ensure UAF 1.2 compliance for all architecture artifacts",
      "system_of_systems_graph_v2.py requires index.json to be created first",
      "Do not skip validation gates - they prevent downstream issues"
    ],
    "validation_loop_critical": [
      "VALIDATION TOOLS ARE NOT OPTIONAL - They are the centerpiece of workflow quality",
      "DO NOT just run validation tools and move on - FIX ALL ISSUES they discover",
      "MANDATORY: Use issue resolution loops in SE-03-A03 and SE-06-A02",
      "READ tool output carefully - errors and warnings indicate real problems",
      "ITERATE until validation passes with ZERO errors - not 'mostly works'",
      "Each validation failure is an architectural issue that MUST be resolved",
      "validate_architecture.py: Fix service-level issues (missing sections, type errors, UAF violations)",
      "system_of_systems_graph_v2.py: Fix system-level issues (circular deps, interface mismatches, orphaned services)",
      "Maximum 5 iterations per validation loop - if exceeding, escalate to user for guidance",
      "Success criteria: Tool completes with zero errors AND architecture makes logical sense"
    ],
    "tool_usage_patterns": {
      "validate_architecture.py": {
        "when": "After creating/modifying any service_architecture.json",
        "pattern": "Run → Analyze errors → Fix → Re-run → Verify clean",
        "do_not": "Skip errors, assume validation passes, proceed with warnings",
        "common_fixes": "Add missing sections, fix JSON syntax, correct UAF violations, resolve referential integrity"
      },
      "system_of_systems_graph_v2.py": {
        "when": "After all services defined and index.json created",
        "pattern": "Run → Analyze graph and output → Fix system-level issues → Re-run → Verify coherence",
        "do_not": "Just check that file was created, ignore warnings, skip graph analysis",
        "common_fixes": "Break circular dependencies, add missing interfaces, fix interface mismatches, connect orphaned services"
      }
    },
    "common_mistakes": [
      "Creating incomplete service_architecture.json (missing required sections)",
      "Not running validation tools",
      "Running validation tools but not fixing issues they find",
      "Assuming validation passed without checking tool output",
      "Proceeding with validation warnings or errors",
      "Not iterating validation loops until clean",
      "Skipping foundational alignment validation",
      "Generating system_of_systems_graph.json before index.json exists",
      "Not analyzing system_of_systems_graph.json for coherence issues",
      "Not updating version_manifest.json"
    ],
    "quality_gates_mandatory": [
      "G-SE-03: Architecture Validation Gate (BLOCKING - validates all architectures pass)",
      "G-SE-05: Specification Completeness Gate (BLOCKING - validates consistency)",
      "G-SE-06: Architecture Completion Gate (BLOCKING - validates system coherence)"
    ]
  }
}
