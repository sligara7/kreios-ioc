{
  "workflow_metadata": {
    "workflow_id": "01c-top_down_design",
    "name": "Top-Down Design Workflow",
    "version": "3.7.0",
    "description": "Design new system architecture from requirements (top-down approach)",
    "created_from": "01-systems_engineering.json v1.0.0 - SE steps extracted",
    "last_updated": "2025-10-27",
    "purpose": "Decompose requirements into services, design architecture, validate system",
    "context_reduction": "Reduced from 1,535 lines to ~700 lines (54% reduction)",
    "approach": "top_down"
  },
  "prerequisites": {
    "required_workflows": [
      "00-setup",
      "01a-approach_detection"
    ],
    "required_files": [
      "context/working_memory.json",
      "context/approach_detection_result.json (with approach=top_down)",
      "docs/SYSTEM_MISSION_STATEMENT.md",
      "docs/USER_SCENARIOS.md",
      "docs/SUCCESS_CRITERIA.md"
    ],
    "required_directories": [
      "specs/machine/service_arch/",
      "specs/machine/interfaces/",
      "specs/machine/graphs/"
    ]
  },
  "workflow_steps": [
    {
      "step_id": "SE-01",
      "name": "System Analysis & Service Decomposition",
      "description": "Analyze system requirements and decompose into services",
      "phase": "analysis",
      "step_file": "workflow_steps/systems_engineering/SE-01-AnalysisAndDecomposition.json",
      "maps_from": "Arch-02: Analysis and Decomposition",
      "actions": [
        {
          "action_id": "SE-01-A01",
          "description": "Run feature analysis",
          "tool": "analyze_features.py",
          "command_pattern": "python3 {reflow_root}/tools/analyze_features.py {system_root}",
          "purpose": "Parse feature requirements and identify required systems/services",
          "inputs": [
            "docs/SYSTEM_MISSION_STATEMENT.md",
            "docs/USER_SCENARIOS.md"
          ],
          "outputs": [
            "Initial service breakdown"
          ]
        },
        {
          "action_id": "SE-01-A02",
          "description": "Classify system hierarchy",
          "purpose": "Determine if this is a single service, multi-service system, or system-of-systems",
          "decision_point": "Single service vs multi-service decomposition",
          "outputs": [
            "System hierarchy classification"
          ]
        },
        {
          "action_id": "SE-01-A03",
          "description": "Decompose into services",
          "purpose": "Break down system into logical services based on business capabilities",
          "guidance": [
            "Follow domain-driven design principles",
            "Identify bounded contexts",
            "Define service responsibilities",
            "Ensure services are cohesive and loosely coupled"
          ],
          "outputs": [
            "List of services with responsibilities"
          ]
        },
        {
          "action_id": "SE-01-A04",
          "description": "Create system decomposition document",
          "template": "system_decomposition_template.json",
          "location": "specs/machine/system_decomposition.json",
          "contains": [
            "Service list with descriptions",
            "Service boundaries",
            "Initial interface requirements",
            "Data ownership"
          ]
        }
      ],
      "tools_used": [
        "analyze_features.py"
      ],
      "templates_used": [
        "system_decomposition_template.json"
      ],
      "outputs": [
        "specs/machine/system_decomposition.json"
      ],
      "gates": [],
      "next_step": "SE-02"
    },
    {
      "step_id": "SE-02",
      "name": "Service Architecture Specification",
      "description": "Create versioned service_architecture.json for each service with comprehensive UAF specifications",
      "phase": "architecture",
      "step_file": "workflow_steps/systems_engineering/SE-02-ServiceArchitecture.json",
      "maps_from": "Arch-02, Arch-03: Service architecture creation and validation",
      "note": "See step_file for complete specifications of all 8 actions (A01-A08)",
      "actions": [
        {
          "action_id": "SE-02-A01",
          "description": "Create versioned service_architecture.json with semantic versioning and symlinks",
          "template": "service_architecture_template.json",
          "output_pattern": "specs/machine/service_arch/{service}/service_architecture_v{semver}-{date}.json"
        },
        {
          "action_id": "SE-02-A02",
          "description": "Define component specifications for internal service components",
          "template": "component_specification_complete_template.json"
        },
        {
          "action_id": "SE-02-A02B",
          "description": "Plan edge weights if framework requires flow analysis (CONDITIONAL)",
          "condition": "Frameworks requiring edge weights: decision_flow, ecological (see step_file)"
        },
        {
          "action_id": "SE-02-A03",
          "description": "Define interface registry cataloging all service interfaces",
          "template": "interface_registry_enhanced_template.json",
          "output": "specs/machine/interface_registry.json"
        },
        {
          "action_id": "SE-02-A04",
          "description": "Assign ports and create port registry (CONDITIONAL - UAF/IT systems only)",
          "template": "port_registry_template.json",
          "output": "specs/machine/port_registry.json",
          "condition": "Only for frameworks with network services (UAF)"
        },
        {
          "action_id": "SE-02-A05",
          "description": "Create security architecture (CONDITIONAL - UAF with human users/external APIs)",
          "template": "security_architecture_template.json",
          "output": "specs/machine/security_architecture.json",
          "condition": "Required for systems with human users or external API access"
        },
        {
          "action_id": "SE-02-A06",
          "description": "Create deployment architecture (CONDITIONAL - UAF/IT systems)",
          "template": "deployment_architecture_template.json",
          "output": "specs/machine/deployment_architecture.json",
          "condition": "Required for IT systems requiring deployment infrastructure"
        },
        {
          "action_id": "SE-02-A07",
          "description": "Create UX and API design architecture (CONDITIONAL - UAF with users/APIs)",
          "template": "ux_api_design_template.json",
          "output": "specs/machine/ux_api_design.json",
          "condition": "Required for systems with human users or external API consumers"
        },
        {
          "action_id": "SE-02-A08",
          "description": "Design operational environment (CONDITIONAL - UAF production systems)",
          "template": "operational_environment_template.json",
          "output": "specs/machine/operational_environment.json",
          "condition": "Required for systems going to production - defines operational conditions and testing strategy"
        },
        {
          "action_id": "SE-02-A09",
          "description": "Define operational testing objectives for each service",
          "template": "operational_testing_objectives_template.json",
          "output": "specs/machine/service_arch/{service}/operational_testing_objectives.json",
          "new_in_version": "v3.6.0 - Early Testing Integration"
        },
        {
          "action_id": "SE-02-A10",
          "description": "Perform risk assessment for each service to guide testing thoroughness",
          "template": "service_risk_assessment_template.json",
          "output": "specs/machine/service_arch/{service}/risk_assessment.json",
          "new_in_version": "v3.6.0 - Early Testing Integration"
        }
      ],
      "tools_used": [
        "validate_port_registry.py"
      ],
      "templates_used": [
        "service_architecture_template.json",
        "component_specification_complete_template.json",
        "interface_registry_enhanced_template.json",
        "port_registry_template.json",
        "security_architecture_template.json",
        "deployment_architecture_template.json",
        "ux_api_design_template.json",
        "operational_environment_template.json",
        "operational_testing_objectives_template.json",
        "service_risk_assessment_template.json"
      ],
      "outputs": [
        "specs/machine/service_arch/{service}/service_architecture_v{semver}-{date}.json (per service)",
        "specs/machine/interface_registry.json",
        "specs/machine/port_registry.json (if UAF/IT)",
        "specs/machine/security_architecture.json (if UAF with users)",
        "specs/machine/deployment_architecture.json (if UAF/IT)",
        "specs/machine/ux_api_design.json (if UAF with users/APIs)",
        "specs/machine/operational_environment.json (if UAF production)",
        "specs/machine/service_arch/{service}/operational_testing_objectives.json (NEW v3.6.0)",
        "specs/machine/service_arch/{service}/risk_assessment.json (NEW v3.6.0)"
      ],
      "gates": [],
      "next_step": "SE-03"
    },
    {
      "step_id": "SE-03",
      "name": "Constraints & Template Validation",
      "description": "Validate all service architectures against templates and constraints",
      "phase": "validation",
      "step_file": "workflow_steps/systems_engineering/SE-03-ConstraintsValidation.json",
      "maps_from": "Arch-03: Constraints and Template Validation",
      "actions": [
        {
          "action_id": "SE-03-A01",
          "description": "Run architecture validation for each service",
          "tool": "validate_architecture.py",
          "command_pattern": "python3 {reflow_root}/tools/validate_architecture.py {system_root} --service {service_name}",
          "purpose": "Ensure service_architecture.json complies with template",
          "validation_checks": [
            "All required sections present",
            "UAF 1.2 compliance",
            "JSON schema validation",
            "Referential integrity"
          ]
        },
        {
          "action_id": "SE-03-A02",
          "description": "Validate constraints",
          "checks": [
            "Technical constraints (language, frameworks, libraries)",
            "Deployment constraints (cloud provider, container orchestration)",
            "Security constraints (authentication, authorization, encryption)",
            "Performance constraints (latency, throughput, scalability)"
          ]
        },
        {
          "action_id": "SE-03-A03",
          "description": "Issue Resolution Loop - Fix validation errors iteratively",
          "pattern": "MANDATORY LOOP - Do not skip this",
          "loop_structure": {
            "step_1": "Run validate_architecture.py for service",
            "step_2": "Capture and analyze ALL errors and warnings from tool output",
            "step_3": "Categorize issues (missing sections, type errors, UAF violations, referential integrity)",
            "step_4": "Fix issues by category (see common_issues below)",
            "step_5": "Re-run validate_architecture.py on same service",
            "step_6": "If errors remain, LOOP back to step_2",
            "step_7": "If validation passes (zero errors), move to next service",
            "termination": "Loop continues until zero errors OR max 5 iterations (then escalate to user)"
          },
          "common_issues_and_fixes": [
            {
              "issue": "Missing required section (e.g., data_models, deployment_architecture)",
              "fix": "Add section from template, populate with service-specific content",
              "tool_reference": "Check templates/service_architecture_template.json for required structure"
            },
            {
              "issue": "Invalid JSON structure or syntax",
              "fix": "Fix JSON syntax errors, ensure valid brackets/braces/commas",
              "verification": "Use JSON validator before re-running architecture validation"
            },
            {
              "issue": "UAF 1.2 compliance violation",
              "fix": "Review definitions/architectural_definitions.json for UAF requirements, update architecture accordingly",
              "examples": "Wrong classification, missing mandatory fields, incorrect nesting"
            },
            {
              "issue": "Referential integrity error (interface not found in registry)",
              "fix": "Either add missing interface to interface_registry.json OR correct interface reference in service_architecture.json",
              "cross_check": "Verify interface exists in specs/machine/interface_registry.json"
            },
            {
              "issue": "Type mismatch (field expects array but got string)",
              "fix": "Correct field type to match template schema",
              "tool_reference": "Check template for correct types"
            },
            {
              "issue": "Empty or placeholder values in required fields",
              "fix": "Replace placeholders with actual architectural decisions",
              "examples": "REPLACE_WITH_X, TBD, TODO must be replaced with real values"
            }
          ],
          "llm_agent_instructions": [
            "DO NOT proceed to next service until current service passes validation",
            "DO NOT skip errors - every error must be fixed",
            "DO NOT assume validation passes - always check tool output",
            "READ the actual error messages from validate_architecture.py carefully",
            "If same error appears 3+ times, re-read template and definitions to understand requirement",
            "Track iteration count - if exceeding 5 iterations, review your approach"
          ],
          "success_criteria": "validate_architecture.py returns zero errors for the service"
        },
        {
          "action_id": "SE-03-A04",
          "description": "Validate port registry for conflicts (CONDITIONAL - only if port_registry.json exists)",
          "condition": {
            "check": "framework_registry.json -> frameworks[framework_id].deployment_characteristics.port_management_applicable == true",
            "if_true": "Validate port_registry.json for conflicts",
            "if_false": "Skip this action - port registry not applicable for non-IT systems",
            "note": "This action only runs if SE-02-A04 was executed (i.e., port_registry.json exists)"
          },
          "tool": "validate_port_registry.py",
          "command_pattern": "python3 {reflow_root}/tools/validate_port_registry.py {system_root}/specs/machine/port_registry.json",
          "purpose": "Ensure no port conflicts exist before development begins (IT systems only)",
          "validation_checks": [
            "PC-01: No duplicate primary ports across services",
            "PC-02: No port overlap between any service ports (primary, metrics, admin)",
            "PC-03: Ports within designated ranges (app:8000-8099, internal:8100-8199, etc.)",
            "PC-04: Avoid privileged ports below 1024",
            "PC-05: Docker host-container port mapping consistency"
          ],
          "common_port_conflicts": {
            "duplicate_primary_ports": {
              "symptom": "Two services assigned same primary port (e.g., both on 8000)",
              "fix": "Reassign second service to next available port in range",
              "prevention": "Use sequential allocation within ranges"
            },
            "metrics_conflicts_with_primary": {
              "symptom": "Service A metrics port (9001) conflicts with Service B primary (9001)",
              "fix": "Shift metrics ports to separate range or use primary+1000 pattern",
              "prevention": "Standardize metrics port allocation pattern"
            },
            "well_known_port_conflicts": {
              "symptom": "Service assigned port 5432 conflicts with PostgreSQL",
              "fix": "Check third_party_defaults in port_ranges, avoid those ports",
              "prevention": "Reserve well-known ports for their intended services"
            }
          },
          "success_criteria": "validate_port_registry.py returns zero errors",
          "blocking": "Yes - port conflicts MUST be resolved before development",
          "rationale": "Catching port conflicts now prevents 'Address already in use' errors during deployment and testing phases"
        },
        {
          "action_id": "SE-03-A05",
          "description": "Validate security architecture (CONDITIONAL - if security_architecture.json exists)",
          "condition": {
            "check": "security_architecture.json exists in specs/machine/",
            "if_true": "Validate security architecture for completeness and best practices",
            "if_false": "Skip - security architecture not required for internal-only systems"
          },
          "validation_type": "Manual review + automated checks",
          "validation_checks": [
            "Authentication strategy defined and appropriate for user types",
            "Authorization model (RBAC/ABAC) complete with roles and permissions",
            "API gateway configuration includes SSL/TLS, CORS, rate limiting",
            "Rate limiting strategy defined with specific limits",
            "Input validation covers XSS and SQL injection prevention",
            "Encryption specified for both in-transit (TLS 1.2+) and at-rest (AES-256)",
            "Audit logging configured with retention policy and alerting",
            "Security testing approach defined (SAST, dependency scanning)"
          ],
          "common_issues": {
            "weak_authentication": {
              "symptom": "No MFA for privileged users, weak password policy",
              "fix": "Enable MFA for admin roles, enforce strong password requirements",
              "security_impact": "HIGH - weak auth leads to account compromise"
            },
            "missing_api_gateway": {
              "symptom": "Services exposed directly without gateway",
              "fix": "Add api_gateway service, route all external traffic through it",
              "security_impact": "CRITICAL - no centralized auth, rate limiting, or request validation"
            },
            "insufficient_rate_limiting": {
              "symptom": "No rate limits or very high limits",
              "fix": "Define reasonable per-user and per-IP limits (e.g., 100 req/min)",
              "security_impact": "MEDIUM - vulnerable to DoS and brute force attacks"
            },
            "no_encryption_at_rest": {
              "symptom": "Sensitive data stored in plaintext",
              "fix": "Identify sensitive fields (passwords, PII, tokens), encrypt with AES-256",
              "security_impact": "HIGH - data breach exposes sensitive information"
            }
          },
          "review_questions": [
            "Is the authentication flow simple enough for users to understand?",
            "Are error messages helpful without exposing security details?",
            "Is the security approach proportional to the threat model?",
            "Are there clear procedures for security incidents?",
            "Is secret management automated and secure?"
          ],
          "success_criteria": "Security architecture addresses all threat vectors, follows industry best practices, and provides positive UX",
          "blocking": "Yes - security gaps MUST be addressed before development",
          "rationale": "Security vulnerabilities discovered after implementation are 10x more expensive to fix than during design"
        },
        {
          "action_id": "SE-03-A06",
          "description": "Validate deployment architecture (CONDITIONAL - if deployment_architecture.json exists)",
          "condition": {
            "check": "deployment_architecture.json exists in specs/machine/",
            "if_true": "Validate deployment architecture for ease and completeness",
            "if_false": "Skip - deployment architecture not required for non-IT systems"
          },
          "validation_type": "Manual review + automated checks",
          "validation_checks": [
            "Deployment philosophy emphasizes simplicity and ease",
            "One-command deployment strategy defined (docker-compose up -d OR kubectl apply)",
            "Containerization with Docker/Podman using official base images",
            "Orchestration choice justified (docker-compose for simplicity OR kubernetes for scale)",
            "CI/CD pipeline defined with build, test, deploy stages",
            "Environment management covers dev, staging, production with parity",
            "Service discovery mechanism defined (DNS, health checks)",
            "Monitoring and observability strategy complete (metrics, logging, alerting)",
            "Backup and disaster recovery with defined RTO/RPO"
          ],
          "common_issues": {
            "overcomplicated_orchestration": {
              "symptom": "Using Kubernetes for 3-service system that doesn't need it",
              "fix": "Simplify to docker-compose unless scale/HA features truly needed",
              "impact": "Increases deployment complexity, slows iteration"
            },
            "no_health_checks": {
              "symptom": "Services don't expose /health or /ready endpoints",
              "fix": "Add health check endpoints to all services, configure in orchestrator",
              "impact": "Can't detect service failures, no automated recovery"
            },
            "manual_deployment_steps": {
              "symptom": "Deployment requires multiple manual commands or configuration",
              "fix": "Automate in single command or script, document in README",
              "impact": "Error-prone deployments, slow onboarding for new developers"
            },
            "no_rollback_strategy": {
              "symptom": "No defined procedure to revert failed deployments",
              "fix": "Define rollback command/procedure, test it works",
              "impact": "Failed deployments cause prolonged outages"
            },
            "missing_observability": {
              "symptom": "No metrics, logging, or alerting defined",
              "fix": "Add Prometheus metrics, centralized logging, critical alerts",
              "impact": "Can't diagnose issues, blind to system health"
            }
          },
          "review_questions": [
            "Can a new developer deploy the entire system in < 10 minutes?",
            "Is the deployment process documented step-by-step in README?",
            "Is rollback simple and fast (< 5 minutes)?",
            "Are health checks comprehensive enough to detect failures?",
            "Is the infrastructure reproducible (IaC) or manual?",
            "Are there clear procedures for scaling up/down?"
          ],
          "success_criteria": "Deployment is simple, automated, well-documented, and enables rapid iteration",
          "blocking": "Yes - complex or undocumented deployment will slow development and increase errors",
          "rationale": "Deployment ease directly impacts development velocity and system reliability"
        },
        {
          "action_id": "SE-03-A07",
          "description": "Validate UX and API design architecture (CONDITIONAL - if ux_api_design.json exists)",
          "condition": {
            "check": "ux_api_design.json exists in specs/machine/",
            "if_true": "Validate UX and API design for clarity, consistency, and developer-friendliness",
            "if_false": "Skip - UX/API design not required for internal machine-to-machine systems"
          },
          "validation_type": "Manual review + automated checks",
          "validation_checks": [
            "UX philosophy defined with clear user types and goals",
            "API design principles follow REST/GraphQL best practices",
            "API endpoints follow consistent naming and structure",
            "Error handling provides user-friendly messages with recovery guidance",
            "API documentation includes OpenAPI spec, interactive docs, code examples",
            "Versioning strategy defined (url_path recommended) with deprecation policy",
            "Performance targets set (p50, p95, p99 latency)",
            "Rate limiting transparent with clear headers and error messages",
            "Authentication UX is simple with clear token management",
            "API gateway defined with responsibilities (auth, rate limiting, routing)"
          ],
          "common_issues": {
            "inconsistent_api_design": {
              "symptom": "Some endpoints use camelCase, others snake_case; mixed naming conventions",
              "fix": "Standardize on single convention (snake_case recommended), document in API design",
              "impact": "Developer confusion, harder to use API"
            },
            "poor_error_messages": {
              "symptom": "Errors like '500 Internal Server Error' or technical jargon",
              "fix": "Return helpful messages: 'Email is required. Please provide your email address.'",
              "impact": "Users can't recover from errors, support burden increases"
            },
            "missing_api_documentation": {
              "symptom": "No OpenAPI spec, no interactive docs, no code examples",
              "fix": "Create OpenAPI 3.0 spec, generate Swagger UI docs, add curl/Python/JS examples",
              "impact": "Developers can't use API without extensive trial and error"
            },
            "no_api_gateway": {
              "symptom": "Services exposed directly, no unified entry point",
              "fix": "Add api_gateway service, route all traffic through single base URL",
              "impact": "Inconsistent auth, can't enforce rate limits, poor observability"
            },
            "api_gateway_not_implemented": {
              "symptom": "api_gateway defined in architecture but only scaffolding exists (orphaned service)",
              "fix": "Implement api_gateway with routing, auth, rate limiting, SSL termination",
              "impact": "CRITICAL - system non-functional without working gateway"
            },
            "unclear_versioning": {
              "symptom": "No versioning strategy or using query params/headers (hard to discover)",
              "fix": "Use url_path versioning (/api/v1/users) - most visible and explicit",
              "impact": "Breaking changes break all clients, no migration path"
            }
          },
          "review_questions": [
            "Can a developer make their first successful API call in < 5 minutes from reading docs?",
            "Are error messages helpful and actionable, not just technical failures?",
            "Is the API consistent and predictable across all endpoints?",
            "Does the system have a working API gateway (not just scaffolding)?",
            "Is API documentation complete with examples for common use cases?",
            "Can users easily obtain and manage API tokens/credentials?",
            "Are rate limits clearly communicated with headers and documentation?",
            "Is the UX simple enough for target user skill level?"
          ],
          "api_gateway_validation": {
            "critical": "If api_gateway service exists in architecture, validate it will be FULLY IMPLEMENTED, not orphaned",
            "check_in_SE_06": "system_of_systems_graph_v2.py with --analyze-issues will detect orphaned services",
            "prevention": "Mark api_gateway as critical path service, validate implementation in Development workflow"
          },
          "success_criteria": "UX and API design enables users to succeed quickly with minimal friction",
          "blocking": "Yes - poor UX/API design decisions are expensive to fix after launch",
          "rationale": "User experience determines adoption, retention, and competitive advantage"
        },
        {
          "action_id": "SE-03-A08",
          "description": "Validate operational environment design (CONDITIONAL - if operational_environment.json exists)",
          "condition": {
            "check": "operational_environment.json exists in specs/machine/",
            "if_true": "Validate operational environment addresses all 10 considerations and real-world conditions",
            "if_false": "Skip - operational environment not required for prototypes or non-IT systems"
          },
          "validation_type": "Manual review + checklist validation",
          "validation_checks_10_considerations": [
            {
              "check": "1. Service Decomposition & Boundaries",
              "validation": "Bounded contexts defined, single responsibility per service, data ownership clear (no shared databases), communication patterns chosen (sync vs async)"
            },
            {
              "check": "2. Containerization & Packaging",
              "validation": "Docker strategy defined, base images selected, multi-stage builds planned, orchestration choice justified (ECS vs EKS vs docker-compose)"
            },
            {
              "check": "3. Infrastructure as Code & Automation",
              "validation": "Ansible playbooks planned (deploy, rollback, provision), environment separation defined (dev/staging/prod), dynamic inventory configured"
            },
            {
              "check": "4. CI/CD Pipeline Integration",
              "validation": "Git workflow defined, pipeline stages clear (build, test, deploy), automated testing strategy complete, versioning scheme chosen"
            },
            {
              "check": "5. Scalability & Resilience",
              "validation": "Horizontal scaling strategy defined, fault tolerance patterns chosen (circuit breakers, retries, timeouts), state management clear (stateless vs stateful)"
            },
            {
              "check": "6. Security & Compliance",
              "validation": "IAM roles defined, secrets management strategy clear, VPC design complete, encryption specified (TLS, KMS), compliance requirements addressed"
            },
            {
              "check": "7. Monitoring, Logging, Observability",
              "validation": "Metrics defined (/metrics endpoint), logging strategy clear (JSON, correlation IDs), alerting configured (critical vs warning), dashboards planned"
            },
            {
              "check": "8. Service Discovery & Networking",
              "validation": "Discovery mechanism chosen (Cloud Map, Consul, K8s DNS), API Gateway defined, latency optimization considered"
            },
            {
              "check": "9. Cost Management & Optimization",
              "validation": "Resource sizing estimated, cost optimization strategies defined (spot instances, reserved instances, auto-scaling), tagging strategy clear"
            },
            {
              "check": "10. Testing & Rollback Strategies",
              "validation": "Test types defined (unit, integration, performance, security, chaos, operational), rollback procedures documented, backup/DR strategy clear"
            }
          ],
          "operational_environment_conditions_validation": {
            "real_world_failures_addressed": [
              "Network failures and partitions \u2192 circuit breakers, timeouts, retries",
              "Resource exhaustion \u2192 resource limits, graceful degradation, monitoring",
              "Cascading failures \u2192 bulkheads, fail-fast, rate limiting",
              "Traffic spikes \u2192 auto-scaling, queuing, caching",
              "Security attacks \u2192 WAF, rate limiting, input validation, audit logging",
              "Data corruption \u2192 validation, checksums, backup/restore",
              "Third-party outages \u2192 fallbacks, circuit breakers, cached responses",
              "Configuration drift \u2192 IaC, validation, immutable infrastructure"
            ],
            "test_plan_completeness": "Chaos engineering, load testing, fault injection, penetration testing planned with success criteria"
          },
          "testing_phase_relationship_validation": {
            "critical_check": "Operational environment defines WHICH tests to run and WHY. Testing phase (workflow 04) executes these tests - it doesn't invent new ones.",
            "validation_questions": [
              "Are test types clearly defined (unit, integration, performance, security, chaos, operational)?",
              "Are success criteria established for each test type?",
              "Are operational test scenarios defined (multi-AZ failover, database failover, auto-scaling, backup/restore)?",
              "Is it clear that testing phase executes this plan, not creates a new one?"
            ]
          },
          "common_issues": {
            "missing_consideration": {
              "symptom": "One or more of the 10 considerations not addressed",
              "fix": "Complete all 10 sections in operational_environment.json",
              "impact": "Incomplete operational design leads to production issues and emergency fixes"
            },
            "vague_strategies": {
              "symptom": "Strategies described generically without specific choices (e.g., 'we'll use monitoring' without defining metrics)",
              "fix": "Make concrete decisions: specific tools, specific metrics, specific thresholds",
              "impact": "Vague designs lead to implementation inconsistencies and rework"
            },
            "ideal_conditions_only": {
              "symptom": "Design assumes perfect conditions, doesn't address failures",
              "fix": "Define operational_environment_conditions with real failure scenarios and design responses",
              "impact": "System fails in production under real-world stress"
            },
            "testing_strategy_missing": {
              "symptom": "No clear definition of which tests to run or success criteria",
              "fix": "Complete testing_rollback_strategies section with specific test types and criteria",
              "impact": "Testing phase doesn't know what to validate, important scenarios missed"
            },
            "deferred_decisions": {
              "symptom": "Critical decisions marked as 'TBD' or 'will decide later'",
              "fix": "Make architectural decisions NOW - deferring to testing/operations is too late",
              "impact": "Budget overages and costly program delays from retrofitting production-readiness"
            }
          },
          "review_questions": [
            "Does operational environment address ALL 10 considerations (service decomposition, containerization, IaC, CI/CD, scalability, security, monitoring, networking, cost, testing)?",
            "Are real-world failure conditions (not ideal conditions) explicitly designed for?",
            "Is it clear which tests will run in testing phase and why?",
            "Are success criteria established for operational readiness?",
            "Have concrete technology choices been made (not just 'we'll use monitoring')?",
            "Is the relationship between SE phase (design) and testing phase (execute) clear?",
            "Does design focus on scalability, reliability, security, maintainability for production?"
          ],
          "success_criteria": "Operational environment comprehensively addresses all 10 considerations, designs for real-world failures, defines complete testing strategy with success criteria",
          "blocking": "Yes - incomplete operational environment leads to production issues, budget overages, and program delays",
          "rationale": "Operational environment is architectural decision made NOW. NOT considering it upfront causes 10-100x cost increase to retrofit."
        }
      ],
      "tools_used": [
        "validate_architecture.py",
        "validate_port_registry.py"
      ],
      "outputs": [
        "Validation reports",
        "Corrected service_architecture.json files",
        "Validated port_registry.json",
        "Validated security_architecture.json",
        "Validated deployment_architecture.json",
        "Validated ux_api_design.json",
        "Validated operational_environment.json"
      ],
      "gates": [
        {
          "gate_id": "G-SE-03",
          "name": "Architecture Validation Gate",
          "checks": [
            "All architecture files pass validation",
            "Zero validation errors",
            "All required sections populated",
            "Interface registry complete",
            "Port registry validated with zero port conflicts (if applicable to framework)",
            "Security architecture validated (if UAF with human users) - BLOCKING",
            "Deployment architecture validated (if UAF/IT system) - BLOCKING",
            "UX and API design validated (if UAF with human users/external APIs) - BLOCKING",
            "Operational environment validated (if UAF going to production) - BLOCKING - addresses all 10 considerations and real-world failures"
          ],
          "conditional_checks": {
            "port_registry_validation": "Only required if deployment_characteristics.port_management_applicable == true (i.e., UAF framework)",
            "security_architecture_validation": "Required if framework_id == 'uaf' AND (human users OR external APIs)",
            "deployment_architecture_validation": "Required if framework_id == 'uaf' AND deployment_characteristics.port_management_applicable == true",
            "ux_api_design_validation": "Required if framework_id == 'uaf' AND (human users OR external APIs)",
            "operational_environment_validation": "Required if framework_id == 'uaf' AND system going to production (NOT for prototypes)"
          },
          "upfront_emphasis_gate": {
            "purpose": "Enforce that security, deployment ease, UX, AND operational environment are designed UPFRONT, not as afterthoughts",
            "blocking_rationale": "IT systems in modern, interconnected world MUST be designed for REAL operational conditions from the start. Systems don't operate in benign, vacuum environments.",
            "modern_world_requirements": [
              "Security: Authentication, authorization, encryption, audit logging designed before any code written",
              "Deployment: One-command deployment, automated rollback, comprehensive monitoring designed before development",
              "UX: Intuitive APIs, clear errors, comprehensive docs designed before implementation",
              "API Gateway: If human users/external APIs, gateway MUST exist and be fully implemented (not orphaned)",
              "Operational Environment: Design for failures, attacks, load spikes, network issues UPFRONT. Define which tests to run and why during SE phase."
            ],
            "systems_engineering_vs_testing_phase": {
              "se_phase": "Design for real operational environment, define which tests needed, establish success criteria, make architectural decisions",
              "testing_phase": "Execute tests planned during SE phase, validate system survives operational conditions, measure against baselines",
              "critical_distinction": "Testing phase does NOT define new tests - those are architectural decisions made NOW during SE phase"
            },
            "cost_of_retrofitting": "NOT considering operational environment upfront causes budget overages and costly program delays. Retrofitting production-readiness is 10-100x more expensive than designing for it.",
            "real_world_conditions": "Systems face network failures, resource exhaustion, cascading failures, traffic spikes, security attacks, data corruption, third-party outages, config drift. Design for these NOW, not hope they don't happen."
          },
          "blocking": true
        }
      ],
      "next_step": "SE-04"
    },
    {
      "step_id": "SE-04",
      "name": "Deployment Architecture Reconciliation",
      "description": "Reconcile logical architecture with deployment architecture",
      "phase": "architecture",
      "step_file": "workflow_steps/systems_engineering/SE-04-DeploymentArchitecture.json",
      "maps_from": "Arch-04: Deployment and Deep Dive",
      "actions": [
        {
          "action_id": "SE-04-A01",
          "description": "Define deployment environment",
          "considerations": [
            "Cloud provider (AWS, Azure, GCP, on-premises)",
            "Container orchestration (Kubernetes, Docker Swarm, ECS)",
            "Networking (VPC, subnets, load balancers)",
            "Storage (databases, object storage, caching)"
          ],
          "updates": "deployment_architecture section in service_architecture.json"
        },
        {
          "action_id": "SE-04-A02",
          "description": "Map logical components to deployment units",
          "purpose": "Determine how logical services map to containers, VMs, serverless functions",
          "output": "Deployment mapping in service_architecture.json"
        },
        {
          "action_id": "SE-04-A03",
          "description": "Define infrastructure requirements",
          "includes": [
            "Compute resources (CPU, memory)",
            "Storage resources (disk, IOPS)",
            "Network resources (bandwidth, connections)",
            "Scaling policies (auto-scaling, manual scaling)"
          ]
        },
        {
          "action_id": "SE-04-A04",
          "description": "Update service_architecture.json with deployment details",
          "purpose": "Ensure deployment_architecture section is complete and consistent with logical architecture"
        }
      ],
      "tools_used": [],
      "outputs": [
        "Updated service_architecture.json with deployment details"
      ],
      "gates": [],
      "next_step": "SE-05"
    },
    {
      "step_id": "SE-05",
      "name": "Consistency & Specification Verification",
      "description": "Ensure all specifications are consistent and complete",
      "phase": "verification",
      "step_file": "workflow_steps/systems_engineering/SE-05-ConsistencyVerification.json",
      "maps_from": "Arch-05: Consistency and Specification Verification",
      "actions": [
        {
          "action_id": "SE-05-A01",
          "description": "Cross-service interface consistency check",
          "purpose": "Ensure interfaces between services are consistently defined on both sides",
          "checks": [
            "Producer-consumer interface agreements",
            "Data contract consistency",
            "Protocol compatibility",
            "Version compatibility"
          ]
        },
        {
          "action_id": "SE-05-A02",
          "description": "Validate foundational alignment",
          "tool": "validate_foundational_alignment.py",
          "command_pattern": "python3 {reflow_root}/tools/validate_foundational_alignment.py {system_root}",
          "purpose": "Ensure architecture aligns with foundational documents",
          "checks": [
            "All user scenarios covered by architecture",
            "Success criteria addressable by architecture",
            "Mission statement reflected in design"
          ]
        },
        {
          "action_id": "SE-05-A03",
          "description": "Identify integration points",
          "tool": "identify_integration_points.py",
          "command_pattern": "python3 {reflow_root}/tools/identify_integration_points.py {system_root}",
          "purpose": "Detect potential architectural issues (circular dependencies, missing interfaces, etc.)"
        },
        {
          "action_id": "SE-05-A04",
          "description": "Specification completeness review",
          "checklist": [
            "All services have complete service_architecture.json",
            "All interfaces documented in interface_registry.json",
            "All components have specifications",
            "All data models defined",
            "All constraints captured"
          ]
        }
      ],
      "tools_used": [
        "validate_foundational_alignment.py",
        "identify_integration_points.py"
      ],
      "outputs": [
        "Consistency validation report",
        "Integration point analysis",
        "Foundational alignment report"
      ],
      "gates": [
        {
          "gate_id": "G-SE-05",
          "name": "Specification Completeness Gate",
          "checks": [
            "All specifications complete",
            "Cross-service consistency verified",
            "Foundational alignment validated",
            "No critical integration issues"
          ],
          "blocking": true
        }
      ],
      "next_step": "SE-06"
    },
    {
      "step_id": "SE-06",
      "name": "System Graph Generation",
      "description": "Generate system graph with framework-specific NetworkX analysis, knowledge gap detection, and architectural validation",
      "phase": "artifacts",
      "step_file": "workflow_steps/systems_engineering/SE-06-GraphGeneration.json",
      "maps_from": "Part of Arch-06, extracted for machine-readable artifacts",
      "note": "For architecture updates, see SE-07 (optional); for mixed-version testing, see SE-08 (optional)",
      "criticality": "CRITICAL - This is comprehensive architecture validation, not just graph generation",
      "actions": [
        {
          "action_id": "SE-06-A01",
          "description": "Create index.json catalog with symlinks to latest architecture versions",
          "template": "index_template.json",
          "output": "specs/machine/index.json"
        },
        {
          "action_id": "SE-06-A02",
          "description": "Generate and validate system_of_systems_graph.json with framework-specific NetworkX analysis",
          "tool": "system_of_systems_graph_v2.py",
          "criticality": "CRITICAL - Validates architecture quality, detects issues, requires framework-appropriate analysis selection",
          "note": "See step_file for: analysis selection guidance, validation loop, issue detection, LLM agent instructions"
        },
        {
          "action_id": "SE-06-A03",
          "description": "Create version_manifest.json tracking architecture version history",
          "template": "version_manifest_template.json",
          "output": "specs/machine/version_manifest.json"
        },
        {
          "action_id": "SE-06-A04",
          "description": "Finalize and verify all machine-readable architecture products",
          "verification": "All required files present and valid (index, graphs, version manifest)"
        },
        {
          "action_id": "SE-06-A05",
          "description": "Define comprehensive system test strategy based on complete architecture and risk assessments",
          "template": "system_test_strategy_template.json",
          "output": "specs/machine/system_test_strategy.json",
          "new_in_version": "v3.6.0 - Early Testing Integration"
        }
      ],
      "tools_used": [
        "system_of_systems_graph_v2.py"
      ],
      "templates_used": [
        "index_template.json",
        "version_manifest_template.json",
        "system_test_strategy_template.json"
      ],
      "outputs": [
        "specs/machine/index.json",
        "specs/machine/graphs/system_of_systems_graph.json",
        "specs/machine/architecture_issues.json",
        "specs/machine/version_manifest.json",
        "context/working_memory.json (updated with analysis_configuration)",
        "specs/machine/system_test_strategy.json (NEW v3.6.0)"
      ],
      "gates": [
        {
          "gate_id": "G-SE-06",
          "name": "Architecture Completion Gate",
          "checks": [
            "All machine-readable artifacts present",
            "system_of_systems_graph.json generated successfully with framework-appropriate analyses",
            "No CRITICAL architectural issues detected",
            "index.json catalogs all artifacts",
            "version_manifest.json tracks all service versions"
          ],
          "blocking": true
        }
      ],
      "next_step": "complete"
    },
    {
      "step_id": "SE-07",
      "name": "Architecture Evolution (OPTIONAL - For Updates)",
      "description": "Update existing architecture with proper versioning",
      "phase": "evolution",
      "optional": true,
      "when_to_use": "When updating existing service architecture to new version",
      "step_file": "workflow_steps/systems_engineering/SE-07-ArchitectureEvolution.json",
      "actions": [
        {
          "action_id": "SE-07-A01",
          "description": "Determine appropriate version increment",
          "semantic_versioning_rules": {
            "major": "Breaking interface changes, fundamental architecture changes (v1.x.x \u2192 v2.0.0)",
            "minor": "New capabilities, non-breaking interface additions (v1.0.x \u2192 v1.1.0)",
            "patch": "Bug fixes, clarifications, documentation improvements (v1.0.0 \u2192 v1.0.1)"
          },
          "examples": {
            "major_change": "Changed authentication API from JWT to OAuth 2.0 (breaks clients)",
            "minor_change": "Added new optional API endpoint (backward compatible)",
            "patch_change": "Fixed typo in architecture description"
          },
          "output": "New version number: v{major}.{minor}.{patch}-{YYYYMMDD}"
        },
        {
          "action_id": "SE-07-A02",
          "description": "Create new versioned architecture file",
          "pattern": "service_architecture_v{new_version}-{YYYYMMDD}.json",
          "location": "specs/machine/service_arch/{service_name}/",
          "preservation_rule": "NEVER delete or overwrite old version - copy and modify",
          "command_example": "cp service_architecture_v1.0.0-20251024.json service_architecture_v2.0.0-20251030.json"
        },
        {
          "action_id": "SE-07-A03",
          "description": "Update architecture content in new version file",
          "purpose": "Make actual architecture changes in new versioned file",
          "note": "Old version remains unchanged for rollback and comparison"
        },
        {
          "action_id": "SE-07-A04",
          "description": "Update symlink to point to new version",
          "commands": [
            "cd specs/machine/service_arch/{service_name}",
            "rm service_architecture.json",
            "ln -s service_architecture_v{new_version}-{YYYYMMDD}.json service_architecture.json"
          ],
          "purpose": "Tools now automatically use new version via symlink"
        },
        {
          "action_id": "SE-07-A05",
          "description": "Update version_manifest.json",
          "actions": [
            "Add new version entry to versions array for this service",
            "Update latest_version field to point to new version",
            "Set change_type (major/minor/patch)",
            "Add description of what changed"
          ],
          "preservation": "Keep all old version entries - never delete history"
        },
        {
          "action_id": "SE-07-A06",
          "description": "Run validation on new version",
          "tool": "validate_architecture.py",
          "command": "python3 {reflow_root}/tools/validate_architecture.py {system_root}",
          "note": "Validates via symlink, so validates new version",
          "success_criteria": "All validations pass"
        },
        {
          "action_id": "SE-07-A07",
          "description": "Regenerate system_of_systems_graph.json",
          "tool": "system_of_systems_graph_v2.py",
          "command": "python3 {reflow_root}/tools/system_of_systems_graph_v2.py {system_root}",
          "note": "Uses symlinks from index.json, so automatically uses new version"
        },
        {
          "action_id": "SE-07-A08",
          "description": "Update human-readable documentation (if exists)",
          "note": "See artifacts workflow (AV-03-A02) for creating versioned system_description.md",
          "pairing_rule": "Human doc version must match architecture version"
        }
      ],
      "tools_used": [
        "validate_architecture.py",
        "system_of_systems_graph_v2.py"
      ],
      "outputs": [
        "New versioned service_architecture.json file",
        "Updated symlink",
        "Updated version_manifest.json",
        "Regenerated system_of_systems_graph.json"
      ],
      "rollback_support": {
        "description": "Easy rollback to previous version if issues found",
        "procedure": [
          "Update symlink to point back to old version",
          "Update version_manifest.json latest_version field",
          "Regenerate system_of_systems_graph.json",
          "All historical versions preserved"
        ]
      },
      "gates": [],
      "next_step": "complete"
    },
    {
      "step_id": "SE-08",
      "name": "Mixed-Version Validation (OPTIONAL)",
      "description": "Test specific combinations of service versions",
      "phase": "validation",
      "optional": true,
      "when_to_use": "Testing partial upgrades, compatibility across versions, deployment scenarios",
      "step_file": "workflow_steps/systems_engineering/SE-08-MixedVersionValidation.json",
      "use_cases": [
        "Validate auth_service v2.0 works with api_gateway v1.0 before deploying",
        "Test compatibility of different service version combinations",
        "Create baseline snapshots for regression testing",
        "Document known-good version combinations"
      ],
      "actions": [
        {
          "action_id": "SE-08-A01",
          "description": "Create version-specific index file",
          "naming_convention": "index_v{scenario_description}-{YYYYMMDD}.json",
          "location": "specs/machine/index_v{scenario}-{date}.json",
          "example_filename": "index_v2.0-auth-v1.0-gateway-20251030.json",
          "content_structure": {
            "components": {
              "{service_name}": "specs/machine/service_arch/{service}/service_architecture_v{specific_version}-{date}.json"
            },
            "version_scenario": {
              "name": "Descriptive scenario name",
              "created_date": "YYYY-MM-DD",
              "purpose": "Why this version combination is being tested",
              "services_versions": {
                "{service_name}": "v{version}-{date}"
              }
            }
          },
          "note": "Points directly to specific versioned files (not symlinks)"
        },
        {
          "action_id": "SE-08-A02",
          "description": "Run validation on version-specific index",
          "tool": "validate_architecture.py",
          "command": "python3 {reflow_root}/tools/validate_architecture.py {system_root} --index specs/machine/index_v{scenario}-{date}.json",
          "purpose": "Validate this specific combination of service versions",
          "checks": [
            "Interface contract compatibility",
            "Breaking changes between versions",
            "Integration issues",
            "Dependency conflicts"
          ]
        },
        {
          "action_id": "SE-08-A03",
          "description": "Generate version-specific system graph",
          "tool": "system_of_systems_graph_v2.py",
          "command": "python3 {reflow_root}/tools/system_of_systems_graph_v2.py {system_root}/specs/machine/index_v{scenario}-{date}.json --output specs/machine/graphs/system_of_systems_graph_v{scenario}-{date}.json",
          "purpose": "Create graph showing this specific version combination",
          "output": "specs/machine/graphs/system_of_systems_graph_v{scenario}-{date}.json"
        },
        {
          "action_id": "SE-08-A04",
          "description": "Analyze compatibility issues",
          "analysis_areas": [
            "Interface mismatches between service versions",
            "Breaking changes causing integration failures",
            "Deprecated features still in use",
            "Version dependency conflicts"
          ],
          "output": "Compatibility analysis report"
        },
        {
          "action_id": "SE-08-A05",
          "description": "Document validation results",
          "location": "specs/human/reports/VERSION_COMPATIBILITY_v{scenario}-{date}.md",
          "includes": [
            "Version combination tested",
            "Validation results (pass/fail)",
            "Compatibility issues found",
            "Recommendations (safe to deploy / needs fixes)",
            "Rollback plan if deployed"
          ]
        },
        {
          "action_id": "SE-08-A06",
          "description": "Update version_manifest.json with new index and graph",
          "actions": [
            "Add entry to version_indexes array",
            "Add entry to system_graphs array",
            "Link index to corresponding graph"
          ],
          "purpose": "Track all tested version combinations"
        }
      ],
      "tools_used": [
        "validate_architecture.py",
        "system_of_systems_graph_v2.py"
      ],
      "outputs": [
        "Version-specific index file",
        "Version-specific system graph",
        "Compatibility analysis report",
        "Updated version_manifest.json"
      ],
      "gates": [],
      "next_step": "complete"
    }
  ],
  "quality_gates": {},
  "next_workflow": "02-artifacts_visualization"
}