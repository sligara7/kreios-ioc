{
  "template_version": "1.0",
  "template_description": "Operational environment architecture for IT systems. Defines real-world operational conditions, scalability, reliability, security, and maintainability UPFRONT during systems engineering - not as afterthought during testing.",
  "applicability": {
    "framework": "uaf",
    "system_type": "IT systems deployed to production environments",
    "mandatory_when": "Any IT system that will operate in real-world production environment",
    "optional_when": "Research prototypes with no production deployment"
  },
  "operational_environment_philosophy": {
    "core_principle": "Systems do NOT operate in benign, vacuum environments. Real operational environments have failures, attacks, load spikes, network partitions, and resource constraints. Design for reality, not ideal conditions.",
    "upfront_design": "Operational environment considerations are ARCHITECTURAL DECISIONS made during systems engineering phase, not operational problems solved during testing phase.",
    "testing_phase_relationship": "Testing phase EXECUTES tests defined here. Which tests to run, why they matter, and success criteria are decided NOW during architecture, not discovered during testing.",
    "cost_impact": "NOT considering operational environment upfront causes budget overages and costly program delays. Retrofitting production-readiness is 10-100x more expensive than designing for it.",
    "production_readiness_factors": [
      "Scalability: Can system handle 10x growth?",
      "Reliability: Can system tolerate failures without user impact?",
      "Security: Can system resist attacks and protect data?",
      "Maintainability: Can system be updated without downtime?"
    ]
  },
  "operational_environment_conditions": {
    "description": "Real-world conditions the system WILL face in production. Design to survive these, not hope they don't happen.",
    "infrastructure_conditions": [
      {
        "condition": "Network failures and partitions",
        "design_response": "Implement timeouts, retries, circuit breakers. Design for eventual consistency where appropriate.",
        "test_plan": "Chaos engineering: Randomly terminate connections, inject latency (100ms-5s), partition services."
      },
      {
        "condition": "Resource exhaustion (CPU, memory, disk)",
        "design_response": "Set resource limits (CPU/memory), implement graceful degradation, monitor resource usage.",
        "test_plan": "Load testing at 2x, 5x, 10x expected traffic. Memory leak detection via sustained load."
      },
      {
        "condition": "Cascading failures",
        "design_response": "Bulkheads, circuit breakers, fail-fast mechanisms, rate limiting.",
        "test_plan": "Fault injection: Kill dependent services, verify system degrades gracefully, not catastrophically."
      },
      {
        "condition": "Traffic spikes and flash crowds",
        "design_response": "Auto-scaling, request queuing, rate limiting, caching.",
        "test_plan": "Spike testing: 10x traffic in 1 minute, verify system scales without errors."
      },
      {
        "condition": "Security attacks (DDoS, credential stuffing, injection)",
        "design_response": "WAF, rate limiting, input validation, audit logging, anomaly detection.",
        "test_plan": "Penetration testing, OWASP Top 10 testing, simulated DDoS (limited scope)."
      },
      {
        "condition": "Data corruption and inconsistency",
        "design_response": "Data validation, checksums, database constraints, backup/restore procedures.",
        "test_plan": "Chaos testing: Corrupt data in database, verify detection and recovery."
      },
      {
        "condition": "Third-party service outages",
        "design_response": "Fallback mechanisms, cached responses, circuit breakers for external APIs.",
        "test_plan": "Dependency failure testing: Simulate external service returning errors/timeouts."
      },
      {
        "condition": "Configuration errors and drift",
        "design_response": "Infrastructure as Code, configuration validation, immutable infrastructure.",
        "test_plan": "Configuration drift detection, validate IaC can recreate environment from scratch."
      }
    ],
    "operational_constraints": {
      "availability_target": "REQUIRED: 99.9% | 99.95% | 99.99% (define SLA)",
      "recovery_time_objective": "REQUIRED: Maximum tolerable downtime (e.g., 1 hour, 4 hours)",
      "recovery_point_objective": "REQUIRED: Maximum tolerable data loss (e.g., 15 minutes, 1 hour)",
      "geographic_distribution": "REQUIRED: single_region | multi_region | global",
      "compliance_requirements": [
        "OPTIONAL: GDPR, HIPAA, PCI-DSS, SOC2, FedRAMP, etc."
      ]
    }
  },
  "service_decomposition_boundaries": {
    "description": "Define clear, bounded contexts using DDD principles to avoid tight coupling and enable independent scaling/deployment",
    "domain_driven_design": {
      "bounded_contexts": [
        {
          "context_name": "EXAMPLE: User Management",
          "responsibility": "User authentication, authorization, profile management",
          "services": ["auth_service", "user_profile_service"],
          "data_ownership": "Dedicated PostgreSQL database: user_db",
          "rationale": "User management is core domain with distinct lifecycle from other domains"
        },
        {
          "context_name": "EXAMPLE: Payment Processing",
          "responsibility": "Payment transactions, refunds, invoicing",
          "services": ["payment_service", "invoice_service"],
          "data_ownership": "Dedicated PostgreSQL database: payment_db (PCI-DSS compliant)",
          "rationale": "Payment processing has strict compliance and security requirements"
        }
      ],
      "anti_corruption_layers": [
        {
          "description": "Payment service → User service",
          "pattern": "Translate payment domain user_id to user management domain user entity",
          "rationale": "Prevent payment domain from being coupled to user domain schema changes"
        }
      ]
    },
    "service_boundaries": {
      "single_responsibility": "Each service handles ONE business capability (e.g., authentication, payment, notification)",
      "cohesion": "High - All functions in service relate to same business capability",
      "coupling": "Low - Services communicate via well-defined interfaces (REST, gRPC, events)",
      "data_ownership": "Each service owns its database - NO shared databases between services",
      "eventual_consistency": "Accept eventual consistency for cross-service data to maintain independence"
    },
    "inter_service_communication": {
      "synchronous_communication": {
        "pattern": "REST APIs via API Gateway",
        "use_when": "Real-time responses required (e.g., user login, payment authorization)",
        "failure_handling": "Timeouts, retries, circuit breakers, fallback responses",
        "example": "API Gateway → Auth Service (JWT validation)"
      },
      "asynchronous_communication": {
        "pattern": "Event-driven via message queue (SQS, SNS, Kafka on MSK)",
        "use_when": "Fire-and-forget operations, long-running tasks, event notifications",
        "failure_handling": "Dead letter queues, retry policies, idempotent consumers",
        "example": "Payment service publishes 'PaymentCompleted' event → Notification service sends email"
      },
      "communication_protocol_selection": {
        "rest_http": "Default for request-response, human-readable, widely supported",
        "grpc": "Use for high-performance internal service-to-service (binary protocol)",
        "graphql": "Use if clients need flexible queries (frontend APIs)",
        "websockets": "Use for real-time bidirectional communication (chat, live updates)"
      }
    },
    "test_strategy": {
      "unit_tests": "Test service business logic in isolation (mock external dependencies)",
      "integration_tests": "Test service interactions via actual APIs/message queues in test environment",
      "contract_tests": "Verify service interfaces match consumer expectations (Pact, Spring Cloud Contract)",
      "end_to_end_tests": "Test complete user journeys across multiple services"
    }
  },
  "containerization_packaging": {
    "description": "Design services to be containerized from the start for consistent environments across dev, staging, prod",
    "docker_strategy": {
      "base_images": [
        {
          "service_type": "Python services",
          "base_image": "python:3.11-slim",
          "rationale": "Minimal attack surface, official Python image, < 200MB"
        },
        {
          "service_type": "Node.js services",
          "base_image": "node:20-alpine",
          "rationale": "Alpine Linux for minimal size, official Node image"
        },
        {
          "service_type": "Java services",
          "base_image": "eclipse-temurin:17-jre-alpine",
          "rationale": "JRE-only (not JDK) for smaller image, OpenJDK alternative"
        }
      ],
      "multi_stage_builds": {
        "enabled": true,
        "stages": [
          "Build stage: Install dependencies, compile code (large image OK)",
          "Production stage: Copy only artifacts, use slim base image (< 500MB target)"
        ],
        "rationale": "Optimize image sizes for faster deployments and reduced attack surface"
      },
      "dockerfile_standards": {
        "non_root_user": true,
        "health_check": "HEALTHCHECK --interval=30s --timeout=3s --start-period=5s CMD curl -f http://localhost:8000/health || exit 1",
        "env_var_configuration": "Use ENV for configuration, never hardcode secrets",
        "layer_optimization": "Order Dockerfile instructions from least to most frequently changed to maximize cache hits"
      },
      "image_versioning": {
        "tagging_strategy": "semantic_version (v1.2.3) AND git_commit_sha (abc123) AND latest (rolling)",
        "immutable_tags": "Never reuse tags - each build gets unique version",
        "registry": "AWS ECR | DockerHub | GitHub Container Registry | self-hosted"
      },
      "security_scanning": {
        "enabled": true,
        "tools": ["trivy", "snyk", "clair", "grype"],
        "scan_frequency": "Every build in CI/CD pipeline",
        "block_on_critical": true,
        "vulnerability_remediation": "Rebuild images with patched base images weekly"
      }
    },
    "orchestration_platform": {
      "platform": "REQUIRED: ecs | eks | docker_swarm | nomad | docker_compose",
      "ecs_fargate": {
        "applicable": false,
        "use_when": "Serverless container orchestration, no infrastructure management, pay-per-use",
        "task_definitions": "Define CPU/memory, environment variables, secrets from Secrets Manager",
        "service_discovery": "AWS Cloud Map for service-to-service DNS",
        "auto_scaling": "Target tracking based on CPU/memory or custom CloudWatch metrics"
      },
      "eks_kubernetes": {
        "applicable": false,
        "use_when": "Need Kubernetes-native features, multi-cloud portability, complex workloads",
        "cluster_version": "REQUIRED: Kubernetes version (e.g., 1.28)",
        "node_groups": "Managed node groups with auto-scaling, spot instances for cost optimization",
        "pod_autoscaling": "HPA (CPU/memory) + VPA (right-sizing) + Cluster Autoscaler",
        "ingress_controller": "AWS Load Balancer Controller for ALB integration"
      },
      "docker_compose": {
        "applicable": false,
        "use_when": "Development environments, small-scale deployments, simplicity over features",
        "compose_version": "3.8",
        "networks": "Custom bridge networks for service isolation",
        "volumes": "Named volumes for persistence, bind mounts for development only"
      }
    },
    "runtime_dependencies": {
      "package_management": "Pin all dependency versions (requirements.txt, package-lock.json, go.mod)",
      "dependency_scanning": "Scan dependencies for vulnerabilities (Dependabot, Snyk)",
      "minimal_dependencies": "Only include production dependencies in final image, exclude dev/test tools"
    },
    "test_strategy": {
      "container_testing": "Build and run containers in CI/CD to verify they start successfully",
      "integration_testing": "Test multi-container setups with docker-compose in CI/CD",
      "performance_testing": "Measure container startup time (target < 10 seconds), memory footprint"
    }
  },
  "infrastructure_as_code_automation": {
    "description": "All infrastructure provisioned and configured via code for repeatability, version control, and disaster recovery",
    "ansible_configuration_management": {
      "enabled": true,
      "use_for": "Application-layer configuration, deployment automation, service orchestration",
      "playbooks": {
        "location": "REQUIRED: ansible/playbooks/",
        "key_playbooks": [
          "deploy.yml - Deploy services to target environment",
          "rollback.yml - Rollback to previous version",
          "provision.yml - Configure EC2 instances, install dependencies",
          "scale.yml - Scale services up/down"
        ]
      },
      "roles": {
        "location": "ansible/roles/",
        "example_roles": [
          "common - Install base packages (Python, Docker, monitoring agents)",
          "webserver - Configure Nginx/Apache",
          "database - Install and configure PostgreSQL/MySQL",
          "app_service - Deploy application containers"
        ]
      },
      "inventory_management": {
        "dynamic_inventory": true,
        "inventory_plugin": "AWS EC2 plugin",
        "inventory_groups": [
          "dev - Development environment instances",
          "staging - Staging environment instances",
          "prod - Production environment instances"
        ],
        "group_vars": "Environment-specific variables (e.g., database endpoints, instance sizes)",
        "rationale": "Automatically discover and manage instances, no manual inventory updates"
      },
      "secrets_management": {
        "ansible_vault": true,
        "vault_files": "group_vars/prod/vault.yml (encrypted with ansible-vault)",
        "vault_password": "Stored in CI/CD secret manager, never in git",
        "integration_with_aws": "Fetch secrets from AWS Secrets Manager or Parameter Store at runtime"
      },
      "deployment_patterns": {
        "rolling_updates": {
          "serial": "10%",
          "max_fail_percentage": 10,
          "description": "Deploy to 10% of instances at a time, rollback if >10% fail"
        },
        "blue_green_deployment": {
          "description": "Deploy to green environment, switch traffic from blue to green, keep blue for rollback",
          "implementation": "Use AWS ALB target groups, Ansible switches traffic"
        },
        "canary_deployment": {
          "description": "Deploy to 5% of instances, monitor metrics, gradually increase to 100%",
          "monitoring": "Watch error rates, latency, custom business metrics"
        }
      }
    },
    "terraform_infrastructure_provisioning": {
      "enabled": false,
      "use_for": "Provisioning AWS resources (VPCs, subnets, EC2, RDS, S3, IAM)",
      "modules": {
        "location": "terraform/modules/",
        "example_modules": [
          "vpc - Create VPC with public/private subnets across 3 AZs",
          "compute - Provision EC2 Auto Scaling Groups",
          "database - Create RDS instances with read replicas",
          "storage - S3 buckets with versioning and lifecycle policies"
        ]
      },
      "state_management": {
        "backend": "s3",
        "s3_bucket": "terraform-state-{account_id}-{region}",
        "dynamodb_table": "terraform-locks",
        "encryption": true,
        "state_locking": true
      },
      "workspaces": {
        "enabled": true,
        "workspaces": ["dev", "staging", "prod"],
        "rationale": "Manage multiple environments with same Terraform code"
      }
    },
    "environment_isolation": {
      "strategy": "REQUIRED: separate_aws_accounts | separate_vpcs | separate_subnets",
      "dev_environment": {
        "isolation": "Separate VPC or AWS account",
        "cost_optimization": "Use smaller instance types, spot instances",
        "data_strategy": "Synthetic data or anonymized production data"
      },
      "staging_environment": {
        "isolation": "Separate VPC or AWS account",
        "parity_with_prod": "Same infrastructure as prod, smaller scale",
        "data_strategy": "Anonymized production data with realistic volumes"
      },
      "prod_environment": {
        "isolation": "Separate AWS account (recommended for strong isolation)",
        "high_availability": "Multi-AZ deployment, auto-scaling, load balancers",
        "data_strategy": "Live production data with encryption and backups"
      },
      "cross_contamination_prevention": "Ansible inventory groups prevent accidentally deploying prod config to dev"
    },
    "test_strategy": {
      "iac_validation": "terraform plan, terraform validate, ansible-playbook --check --diff",
      "drift_detection": "Run Terraform plan daily to detect manual changes (config drift)",
      "disaster_recovery_drill": "Quarterly: Destroy staging environment, recreate from IaC, verify success"
    }
  },
  "ci_cd_pipeline_integration": {
    "description": "Automated build, test, and deployment pipeline integrated with version control",
    "git_workflow": {
      "branching_strategy": "REQUIRED: gitflow | trunk_based | github_flow",
      "main_branch": "main (protected, requires PR reviews)",
      "feature_branches": "feature/* (merged via PR with automated tests)",
      "release_branches": "release/* (for prod deployments)",
      "hotfix_branches": "hotfix/* (for emergency prod fixes)"
    },
    "pipeline_platform": {
      "tool": "REQUIRED: aws_codepipeline | jenkins | gitlab_ci | github_actions | circleci",
      "pipeline_definition": "REQUIRED: Path to pipeline config (buildspec.yml, Jenkinsfile, .gitlab-ci.yml)",
      "pipeline_stages": [
        {
          "stage": "Source",
          "description": "Trigger on git push to main or feature branches",
          "actions": ["Checkout code", "Set build metadata (commit SHA, timestamp)"]
        },
        {
          "stage": "Build",
          "description": "Compile code, build Docker images, run static analysis",
          "actions": [
            "Install dependencies",
            "Run linters (pylint, eslint, golangci-lint)",
            "Run static security analysis (Bandit, Semgrep)",
            "Build Docker image with commit SHA tag",
            "Push image to ECR"
          ],
          "duration_target": "< 5 minutes",
          "failure_action": "Block pipeline, notify developer"
        },
        {
          "stage": "Test",
          "description": "Run automated tests in containerized environment",
          "test_types": [
            {
              "test_type": "Unit Tests",
              "coverage_threshold": 80,
              "tool": "pytest | jest | JUnit",
              "block_on_failure": true
            },
            {
              "test_type": "Integration Tests",
              "environment": "docker-compose with test dependencies (database, cache)",
              "block_on_failure": true
            },
            {
              "test_type": "Security Tests",
              "scans": [
                "SAST (SonarQube, Semgrep)",
                "Dependency scanning (Snyk, Dependabot)",
                "Container scanning (Trivy, Clair)"
              ],
              "block_on_critical": true
            },
            {
              "test_type": "Performance Tests",
              "tool": "k6 | JMeter | Locust",
              "baseline": "p95 latency < 500ms, throughput > 100 req/sec",
              "block_on_failure": false,
              "alert_on_regression": true
            }
          ],
          "duration_target": "< 10 minutes",
          "failure_action": "Block deployment, detailed test report to developer"
        },
        {
          "stage": "Deploy to Staging",
          "description": "Automated deployment to staging environment for validation",
          "deployment_method": "Ansible playbook: ansible/playbooks/deploy.yml --limit staging",
          "smoke_tests": "Run basic health checks after deployment (curl /health, /ready)",
          "duration_target": "< 5 minutes",
          "failure_action": "Auto-rollback to previous version, alert operations team"
        },
        {
          "stage": "Deploy to Production",
          "description": "Controlled deployment to production with gradual rollout",
          "approval_required": true,
          "approvers": ["Release Manager", "Operations Lead"],
          "deployment_strategy": "Rolling update | Blue-green | Canary (choose in deployment architecture)",
          "deployment_method": "Ansible playbook: ansible/playbooks/deploy.yml --limit prod",
          "monitoring": "Real-time dashboards for error rates, latency, business metrics",
          "auto_rollback_triggers": [
            "Error rate > 5%",
            "p95 latency > 2x baseline",
            "Health check failures > 10%"
          ],
          "duration_target": "< 15 minutes for rolling update",
          "failure_action": "Auto-rollback, page on-call engineer"
        }
      ]
    },
    "versioning_strategy": {
      "artifact_versioning": "Semantic versioning: MAJOR.MINOR.PATCH (e.g., 1.2.3)",
      "docker_image_tagging": "v1.2.3, git-abc123, latest (for staging only, never prod)",
      "version_increments": {
        "MAJOR": "Breaking API changes, major architecture changes",
        "MINOR": "New features, non-breaking API additions",
        "PATCH": "Bug fixes, security patches"
      },
      "version_automation": "Auto-increment version on merge to main using semantic-release or conventional commits"
    },
    "secrets_injection": {
      "method": "Environment variables from AWS Secrets Manager or Parameter Store",
      "ci_cd_integration": "Pipeline fetches secrets at deploy time, injects into containers",
      "rotation": "Automated rotation with AWS Secrets Manager, Ansible updates services"
    },
    "test_strategy": {
      "pipeline_testing": "Validate pipeline works end-to-end in staging before using in prod",
      "deployment_testing": "Test rollback procedures regularly (monthly drill)",
      "chaos_engineering": "Randomly inject failures in staging to validate auto-rollback"
    }
  },
  "scalability_resilience": {
    "description": "Design for horizontal scaling, fault tolerance, and graceful degradation under stress",
    "horizontal_scaling": {
      "enabled": true,
      "stateless_services": [
        "EXAMPLE: api_service - scales based on CPU utilization > 70%",
        "EXAMPLE: worker_service - scales based on queue depth > 100"
      ],
      "scaling_triggers": {
        "cpu_utilization": "Target 70% CPU, scale up if sustained > 5 minutes",
        "memory_utilization": "Target 80% memory",
        "custom_metrics": "Queue depth, request latency, active connections"
      },
      "auto_scaling_configuration": {
        "min_instances": 2,
        "max_instances": 20,
        "scale_out_cooldown": "5 minutes",
        "scale_in_cooldown": "10 minutes (slower to avoid thrashing)",
        "target_tracking": "CPU at 70%, auto-scaling adjusts instance count"
      },
      "load_balancer": {
        "type": "Application Load Balancer (ALB) for HTTP/HTTPS, Network Load Balancer (NLB) for TCP",
        "health_checks": "/health endpoint, 3 consecutive failures = unhealthy",
        "session_affinity": false,
        "rationale": "Stateless services don't need sticky sessions"
      }
    },
    "vertical_scaling": {
      "supported": true,
      "use_when": "Stateful services (databases) that can't scale horizontally easily",
      "resize_strategy": "Manual (requires downtime) or automated with AWS RDS automated scaling (read replicas)",
      "downtime_acceptable": "Maintenance window: Sunday 2-4 AM UTC"
    },
    "fault_tolerance": {
      "circuit_breakers": {
        "enabled": true,
        "library": "Resilience4j | Hystrix | Polly",
        "configuration": {
          "failure_threshold": "50% failures in 10 requests",
          "open_state_duration": "30 seconds",
          "half_open_requests": 5,
          "fallback": "Return cached response or graceful degradation message"
        },
        "example": "Payment service calls external gateway; if gateway fails, circuit opens, returns 'Payment processing temporarily unavailable'"
      },
      "retries": {
        "enabled": true,
        "retry_policy": "Exponential backoff: 1s, 2s, 4s, 8s",
        "max_retries": 3,
        "idempotency": "All retry-able operations must be idempotent",
        "example": "API call to database fails with transient error → retry 3 times before failing"
      },
      "timeouts": {
        "enabled": true,
        "connection_timeout": "5 seconds",
        "read_timeout": "30 seconds",
        "rationale": "Prevent infinite waits, fail fast to avoid cascading failures"
      },
      "bulkheads": {
        "enabled": true,
        "pattern": "Isolate thread pools for different dependencies",
        "example": "Payment service has separate thread pools for database (10 threads) and external API (5 threads). If external API saturates its pool, database operations still work."
      }
    },
    "state_management": {
      "stateless_services": {
        "pattern": "Store state externally (database, cache, S3), not in service memory",
        "rationale": "Enables horizontal scaling, instance replacement without data loss"
      },
      "stateful_services": {
        "databases": {
          "persistence": "AWS RDS with Multi-AZ for high availability",
          "replication": "Read replicas for read-heavy workloads",
          "backups": "Automated daily backups with 7-day retention, point-in-time recovery"
        },
        "caches": {
          "technology": "Redis on AWS ElastiCache",
          "replication": "Redis Cluster with automatic failover",
          "persistence": "AOF (Append-Only File) for durability"
        },
        "file_storage": {
          "technology": "S3 for object storage, EFS for shared file systems",
          "replication": "S3 automatically replicates across AZs",
          "versioning": "S3 versioning enabled for accidental deletion recovery"
        }
      }
    },
    "chaos_engineering": {
      "enabled": false,
      "tool": "AWS Fault Injection Simulator | Chaos Monkey | LitmusChaos",
      "experiments": [
        "Randomly terminate EC2 instances → verify auto-scaling replaces them",
        "Inject network latency (100ms-5s) → verify circuit breakers activate",
        "Exhaust CPU/memory on instances → verify performance degradation, not crashes",
        "Fail database writes → verify retry logic, fallback to read-only mode"
      ],
      "schedule": "Monthly in staging, quarterly in production (controlled blast radius)"
    },
    "test_strategy": {
      "load_testing": "Simulate 2x, 5x, 10x expected traffic using k6 or JMeter",
      "spike_testing": "10x traffic in 1 minute, verify auto-scaling responds",
      "endurance_testing": "Sustained load for 24+ hours, detect memory leaks",
      "failover_testing": "Simulate instance failures, verify auto-scaling and load balancer handle gracefully"
    }
  },
  "security_compliance": {
    "description": "Security built into architecture, not bolted on later. Compliance requirements drive design decisions.",
    "identity_access_management": {
      "iam_roles": "Use IAM roles for services (EC2, ECS tasks), never hard-code credentials",
      "principle_of_least_privilege": "Each service gets minimal IAM permissions (e.g., S3 read-only for specific bucket)",
      "iam_policies": {
        "location": "terraform/modules/iam/ or Ansible roles/iam",
        "review_frequency": "Quarterly - audit IAM policies for over-permissive rules"
      },
      "service_accounts": "Dedicated IAM roles per service, no shared credentials"
    },
    "secrets_management": {
      "tool": "AWS Secrets Manager | AWS Systems Manager Parameter Store | HashiCorp Vault",
      "secret_types": [
        "Database credentials (auto-rotated every 30 days)",
        "API keys for external services",
        "Encryption keys (managed via AWS KMS)",
        "OAuth client secrets"
      ],
      "rotation": {
        "automated": true,
        "rotation_frequency": "30 days for databases, 90 days for API keys",
        "rotation_process": "Secrets Manager triggers Lambda → updates RDS password → updates secret"
      },
      "access_control": "IAM policies restrict which services can access which secrets"
    },
    "network_security": {
      "vpc_design": {
        "public_subnets": "ALB, NAT Gateway only",
        "private_subnets": "Application services, databases (no direct internet access)",
        "availability_zones": "Minimum 3 AZs for high availability"
      },
      "security_groups": {
        "default_deny": "All inbound traffic blocked by default",
        "allow_rules": [
          "ALB → App services on port 8000 (HTTP)",
          "App services → Database on port 5432 (PostgreSQL)",
          "App services → Redis on port 6379"
        ],
        "no_0.0.0.0/0": "Never allow 0.0.0.0/0 on security group inbound (except ALB from internet)"
      },
      "network_acls": {
        "enabled": true,
        "stateless_filtering": "Backup defense layer beyond security groups"
      },
      "vpc_peering": {
        "use_when": "Connect VPCs across environments (dev, staging, prod) or accounts",
        "encryption": "All VPC traffic encrypted with AWS default encryption"
      },
      "aws_waf": {
        "enabled": true,
        "rules": [
          "Rate limiting: 2000 requests per 5 minutes per IP",
          "Block SQL injection patterns",
          "Block XSS patterns",
          "Geo-blocking (if applicable): Block traffic from high-risk countries"
        ],
        "managed_rule_groups": "AWS Managed Rules for OWASP Top 10"
      },
      "mtls": {
        "enabled": false,
        "use_when": "High-security environments require mutual TLS between services",
        "certificate_authority": "AWS Private CA or self-hosted CA"
      }
    },
    "data_encryption": {
      "in_transit": {
        "tls_version": "TLS 1.2 minimum (TLS 1.3 preferred)",
        "alb_tls_termination": "ALB terminates TLS, communicates with backend via HTTP in VPC",
        "internal_service_communication": "HTTP within VPC (trusted network) OR HTTPS for sensitive data",
        "certificate_management": "AWS Certificate Manager (ACM) for automatic renewal"
      },
      "at_rest": {
        "rds_encryption": "Enabled with AWS KMS keys",
        "s3_encryption": "SSE-S3 (AWS-managed keys) or SSE-KMS (customer-managed keys)",
        "ebs_volumes": "Encrypted with KMS keys",
        "application_level_encryption": "Encrypt sensitive fields (PII, passwords) before storing in database"
      },
      "key_management": {
        "kms_keys": "AWS KMS with automatic rotation every 365 days",
        "key_policies": "Restrict key usage to specific IAM roles",
        "key_aliases": "Use aliases (alias/app-encryption-key) for readability"
      }
    },
    "compliance_requirements": {
      "applicable_standards": [
        "OPTIONAL: GDPR - EU data residency, right to erasure, data portability",
        "OPTIONAL: HIPAA - PHI encryption, audit logging, BAA with AWS",
        "OPTIONAL: PCI-DSS - Cardholder data encryption, network segmentation, access logs",
        "OPTIONAL: SOC 2 - Security, availability, confidentiality controls",
        "OPTIONAL: FedRAMP - Government cloud compliance"
      ],
      "data_residency": {
        "required_regions": "REQUIRED: us-east-1 | eu-west-1 | etc.",
        "cross_border_data": "Restrict data replication to compliant regions only"
      },
      "audit_logging": {
        "enabled": true,
        "log_retention": "90 days minimum (365 days for compliance)",
        "log_immutability": "S3 Object Lock for WORM (Write Once Read Many) compliance"
      },
      "right_to_erasure": {
        "gdpr_compliance": "Implement data deletion APIs, verify deletion across all systems"
      }
    },
    "test_strategy": {
      "security_testing": "OWASP Top 10 testing, penetration testing (annual)",
      "compliance_audits": "Quarterly internal audits, annual third-party audits",
      "vulnerability_scanning": "Weekly scans with Nessus or AWS Inspector",
      "incident_response_drills": "Simulate data breach, test incident response playbook"
    }
  },
  "monitoring_logging_observability": {
    "description": "Centralized observability for proactive issue detection, debugging, and performance optimization",
    "metrics_collection": {
      "enabled": true,
      "metrics_format": "Prometheus exposition format (/metrics endpoint)",
      "scrape_interval": "15 seconds",
      "key_metrics": [
        {
          "metric_name": "request_count",
          "type": "counter",
          "labels": ["method", "endpoint", "status_code"],
          "purpose": "Track API request volume"
        },
        {
          "metric_name": "request_duration_seconds",
          "type": "histogram",
          "buckets": [0.01, 0.05, 0.1, 0.5, 1.0, 2.0, 5.0],
          "purpose": "Measure API latency distribution (p50, p95, p99)"
        },
        {
          "metric_name": "error_rate",
          "type": "gauge",
          "purpose": "Track percentage of failed requests"
        },
        {
          "metric_name": "active_connections",
          "type": "gauge",
          "purpose": "Monitor concurrent connections to service"
        },
        {
          "metric_name": "queue_depth",
          "type": "gauge",
          "purpose": "Monitor message queue backlog"
        }
      ],
      "storage_backend": {
        "tool": "Prometheus | AWS CloudWatch | Datadog | Grafana Cloud",
        "retention": "15 days high-resolution, 1 year aggregated"
      }
    },
    "logging": {
      "enabled": true,
      "log_format": "JSON (structured logging for machine parsing)",
      "log_level": {
        "dev": "DEBUG",
        "staging": "INFO",
        "prod": "WARN"
      },
      "log_fields": {
        "required": [
          "timestamp (ISO 8601)",
          "level (DEBUG|INFO|WARN|ERROR)",
          "message",
          "service_name",
          "request_id (for tracing)",
          "user_id (if authenticated)"
        ],
        "optional": [
          "trace_id (for distributed tracing)",
          "span_id",
          "client_ip",
          "user_agent"
        ]
      },
      "log_aggregation": {
        "tool": "AWS CloudWatch Logs | ELK Stack (Elasticsearch, Logstash, Kibana) | Datadog | Splunk",
        "retention": "30 days (90 days for compliance)",
        "search": "Full-text search on log messages, filter by request_id, user_id, service_name"
      },
      "correlation_ids": {
        "request_id": "Generated at API Gateway, propagated to all services",
        "trace_id": "For distributed tracing across microservices",
        "purpose": "Debug requests spanning multiple services using single ID"
      }
    },
    "distributed_tracing": {
      "enabled": false,
      "tool": "AWS X-Ray | Jaeger | Zipkin | Datadog APM",
      "sampling_rate": 0.1,
      "trace_all_requests": false,
      "use_when": "Debugging latency issues in microservices, visualizing request flow",
      "integration": "Instrument services with X-Ray SDK, auto-trace HTTP calls between services"
    },
    "alerting": {
      "enabled": true,
      "alerting_tool": "Prometheus Alertmanager | AWS CloudWatch Alarms | PagerDuty | Opsgenie",
      "notification_channels": ["email", "slack", "pagerduty", "sms"],
      "critical_alerts": [
        {
          "alert_name": "HighErrorRate",
          "condition": "error_rate > 5% for 5 minutes",
          "severity": "critical",
          "action": "Page on-call engineer, auto-rollback if recent deployment"
        },
        {
          "alert_name": "ServiceDown",
          "condition": "health_check_failure for 2 minutes",
          "severity": "critical",
          "action": "Page on-call, attempt auto-restart"
        },
        {
          "alert_name": "HighLatency",
          "condition": "p95_latency > 1000ms for 10 minutes",
          "severity": "critical",
          "action": "Page on-call, check for scaling issues"
        },
        {
          "alert_name": "DatabaseConnectionPoolExhausted",
          "condition": "active_db_connections > 90% of max_connections for 5 minutes",
          "severity": "critical",
          "action": "Page on-call, scale up database or increase connection pool"
        }
      ],
      "warning_alerts": [
        {
          "alert_name": "ModerateErrorRate",
          "condition": "error_rate > 2% for 10 minutes",
          "severity": "warning",
          "action": "Notify team via Slack, investigate during business hours"
        },
        {
          "alert_name": "HighMemoryUsage",
          "condition": "memory_utilization > 85% for 15 minutes",
          "severity": "warning",
          "action": "Monitor for memory leaks, consider scaling up"
        }
      ],
      "alert_fatigue_prevention": {
        "deduplication": "Group similar alerts, don't send duplicate notifications",
        "flapping_prevention": "Require alert to persist for time threshold before firing",
        "on_call_schedule": "PagerDuty rotation, escalation policy if no response in 15 minutes"
      }
    },
    "dashboards": {
      "enabled": true,
      "dashboard_tool": "Grafana | AWS CloudWatch Dashboards | Datadog",
      "key_dashboards": [
        {
          "dashboard_name": "System Overview",
          "metrics": ["Total requests/sec", "Error rate", "p95 latency", "Active users"],
          "refresh_rate": "30 seconds"
        },
        {
          "dashboard_name": "Service Health",
          "metrics": ["Per-service error rates", "Per-service latency", "Instance health"],
          "drill_down": "Click service → view logs, traces, metrics"
        },
        {
          "dashboard_name": "Database Performance",
          "metrics": ["Queries/sec", "Connection pool usage", "Slow query log"],
          "alerts": "Highlight metrics approaching thresholds"
        },
        {
          "dashboard_name": "Business Metrics",
          "metrics": ["Orders/hour", "Revenue", "User signups", "Payment success rate"],
          "audience": "Product, business stakeholders"
        }
      ],
      "access_control": "Read-only access for all engineers, edit access for SRE team"
    },
    "performance_baselines": {
      "p50_latency": "< 100ms",
      "p95_latency": "< 500ms",
      "p99_latency": "< 1000ms",
      "error_rate": "< 0.1%",
      "availability": "99.9%",
      "rationale": "Baselines established from load testing, alerts trigger if degradation from baseline"
    },
    "test_strategy": {
      "monitoring_testing": "Validate metrics, logs, alerts work in staging before prod",
      "alert_testing": "Trigger alerts manually (fail health checks, inject errors), verify notifications sent",
      "dashboard_review": "Monthly review dashboards with team, remove unused panels, add new metrics"
    }
  },
  "service_discovery_networking": {
    "description": "Dynamic service registration and discovery, optimized network routing",
    "service_discovery_mechanism": {
      "tool": "REQUIRED: aws_cloud_map | consul | eureka | kubernetes_service_dns",
      "aws_cloud_map": {
        "applicable": false,
        "use_when": "ECS Fargate or EC2 with dynamic IP addresses",
        "namespace": "app.local (private DNS namespace)",
        "service_registration": "Automatic via ECS service discovery",
        "health_checks": "Cloud Map checks /health endpoint, deregisters unhealthy instances"
      },
      "consul": {
        "applicable": false,
        "use_when": "Multi-cloud or hybrid deployments, need advanced features (KV store, service mesh)",
        "service_registration": "Services register on startup, deregister on shutdown",
        "health_checks": "Consul agent checks HTTP /health endpoint every 10 seconds"
      },
      "kubernetes_service_dns": {
        "applicable": false,
        "use_when": "EKS (Kubernetes) deployment",
        "dns_format": "service-name.namespace.svc.cluster.local",
        "service_types": "ClusterIP (internal), LoadBalancer (external)"
      },
      "hardcoded_endpoints": {
        "applicable": false,
        "use_when": "Simple deployments with static IPs (NOT RECOMMENDED for production)",
        "rationale": "Static IPs break auto-scaling, manual updates required"
      }
    },
    "api_management": {
      "api_gateway": {
        "enabled": true,
        "gateway_type": "AWS API Gateway | Kong | Traefik | NGINX",
        "responsibilities": [
          "Single entry point for external clients (https://api.example.com)",
          "Authentication enforcement (JWT validation)",
          "Rate limiting (per-user, per-IP)",
          "Request/response transformation",
          "SSL/TLS termination",
          "CORS handling",
          "Request ID injection for tracing"
        ],
        "routing": {
          "path_based": "/api/v1/users → user_service, /api/v1/orders → order_service",
          "host_based": "api.example.com → API Gateway, admin.example.com → admin_service",
          "header_based": "X-API-Version: 2 → route to v2 services"
        },
        "caching": {
          "enabled": true,
          "cache_ttl": "300 seconds (5 minutes)",
          "cache_key": "HTTP method + URL path + query params",
          "invalidation": "Manual invalidation via API or automatic on TTL expiry"
        }
      }
    },
    "latency_optimization": {
      "same_vpc_placement": "Place frequently-communicating services in same VPC to reduce latency",
      "availability_zone_placement": "Prefer same AZ for latency-sensitive calls (< 1ms vs 1-2ms cross-AZ)",
      "cdn": {
        "enabled": false,
        "tool": "AWS CloudFront | Fastly | Cloudflare",
        "use_when": "Serve static assets (images, CSS, JS) or cache API responses globally",
        "cache_policy": "Cache static assets for 1 year, API responses for 5 minutes"
      },
      "connection_pooling": {
        "enabled": true,
        "database_connections": "Pool size 20, max overflow 10",
        "http_connections": "Keep-alive enabled, max 100 connections per host"
      }
    },
    "test_strategy": {
      "service_discovery_testing": "Kill instances, verify auto-deregistration and traffic rerouting",
      "latency_testing": "Measure cross-AZ vs same-AZ latency, optimize critical paths",
      "api_gateway_testing": "Load test API Gateway, verify rate limiting and caching work"
    }
  },
  "cost_management_optimization": {
    "description": "Design for cost-efficiency from day one, not as post-deployment cleanup",
    "resource_sizing": {
      "right_sizing": "Start with t3.medium instances, monitor CPU/memory, downsize to t3.small or upsize to t3.large based on usage",
      "vertical_autoscaling": "Use Kubernetes VPA to automatically right-size pods",
      "storage_tiering": {
        "s3_lifecycle_policies": "Transition objects to S3 Glacier after 90 days, delete after 365 days",
        "ebs_snapshots": "Delete old snapshots (keep last 7 days only)"
      }
    },
    "compute_cost_optimization": {
      "spot_instances": {
        "use_for": "Non-critical workloads (batch processing, dev environments)",
        "savings": "Up to 90% vs On-Demand",
        "spot_fleet": "Mix of instance types to maximize availability",
        "interruption_handling": "Graceful shutdown on 2-minute termination notice"
      },
      "reserved_instances": {
        "use_for": "Predictable baseline workload (e.g., always need 5 instances)",
        "commitment": "1-year or 3-year reserved instances",
        "savings": "Up to 75% vs On-Demand"
      },
      "savings_plans": {
        "use_for": "Flexible compute usage across instance families",
        "commitment": "Hourly spend commitment (e.g., $10/hour)",
        "savings": "Up to 72% vs On-Demand"
      },
      "auto_scaling": {
        "scale_to_zero": "Non-prod environments scale to zero instances overnight/weekends",
        "savings": "50-70% reduction in non-prod costs"
      }
    },
    "serverless_options": {
      "aws_lambda": {
        "use_for": "Low-traffic services (< 100 req/min), event-driven processing",
        "billing": "Pay per invocation and duration (no idle costs)",
        "cold_start": "Acceptable for async workloads, problematic for latency-sensitive APIs"
      },
      "fargate": {
        "use_for": "Containers without managing EC2 instances",
        "billing": "Pay per vCPU/memory per second (no idle instance costs)",
        "trade_off": "Higher per-compute cost than EC2, but simpler management"
      }
    },
    "tagging_strategy": {
      "mandatory_tags": [
        "Environment (dev|staging|prod)",
        "Service (user_service|payment_service)",
        "Owner (team-name or email)",
        "CostCenter (engineering|product|sales)"
      ],
      "enforcement": "Terraform/Ansible automatically applies tags, reject untagged resources",
      "cost_allocation": "Use tags to generate per-service, per-environment cost reports in AWS Cost Explorer"
    },
    "monitoring_costs": {
      "aws_cost_explorer": "Weekly review of costs, identify anomalies",
      "budgets_and_alerts": "Set budget ($10k/month), alert at 80% ($8k) and 100% ($10k)",
      "cost_optimization_reviews": "Monthly review with team, identify optimization opportunities"
    },
    "test_strategy": {
      "cost_simulation": "Use AWS Pricing Calculator to estimate architecture costs before deployment",
      "cost_regression_testing": "Track costs over time, alert if costs increase > 20% without traffic increase",
      "resource_cleanup": "Automated deletion of unused resources (old snapshots, stopped instances)"
    }
  },
  "testing_rollback_strategies": {
    "description": "Testing strategies defined NOW during architecture. Testing phase executes these tests. Rollback must be fast and reliable.",
    "testing_strategy": {
      "test_types_to_run": {
        "unit_tests": {
          "coverage_target": "80%",
          "run_when": "Every commit in CI/CD",
          "success_criteria": "All tests pass, coverage > 80%"
        },
        "integration_tests": {
          "description": "Test service interactions via real APIs/databases in isolated environment",
          "run_when": "Every merge to main branch",
          "environment": "docker-compose with all services + dependencies",
          "success_criteria": "All API contracts fulfilled, no integration errors"
        },
        "end_to_end_tests": {
          "description": "Test complete user journeys across multiple services",
          "run_when": "Pre-deployment to staging",
          "scenarios": ["User signup → login → create resource → delete resource"],
          "success_criteria": "All user journeys complete successfully"
        },
        "performance_tests": {
          "description": "Load testing at 2x, 5x, 10x expected traffic",
          "run_when": "Weekly in staging, before major releases",
          "tool": "k6 | JMeter | Locust",
          "success_criteria": "p95 latency < 500ms at 5x traffic, no errors"
        },
        "security_tests": {
          "description": "OWASP Top 10, penetration testing, dependency scanning",
          "run_when": "Every build (SAST, dependency scan), quarterly (pen test)",
          "success_criteria": "Zero critical vulnerabilities"
        },
        "chaos_tests": {
          "description": "Inject failures (kill instances, network latency, resource exhaustion)",
          "run_when": "Monthly in staging, quarterly in prod (controlled)",
          "success_criteria": "System degrades gracefully, auto-recovers"
        },
        "operational_tests": {
          "description": "Validate system operates in real operational environment",
          "run_when": "Before production deployment",
          "scenarios": [
            "Multi-AZ failover: Kill instances in one AZ, verify traffic routes to other AZs",
            "Database failover: Promote read replica to master, verify application reconnects",
            "Auto-scaling: Inject high load, verify auto-scaling triggers and succeeds",
            "Backup/restore: Restore from backup, verify data integrity",
            "Deployment/rollback: Deploy new version, rollback, verify no data loss"
          ],
          "success_criteria": "System survives all operational failure scenarios"
        }
      },
      "test_environments": {
        "dev": "Developer laptops with docker-compose",
        "ci_cd": "Automated tests run in containerized CI/CD environment",
        "staging": "Production-like environment for pre-deployment validation",
        "prod": "Live production environment (chaos tests with limited blast radius)"
      }
    },
    "canary_deployments": {
      "enabled": false,
      "deployment_stages": [
        {"percentage": 5, "duration": "15 minutes", "rollback_if": "error_rate > 1%"},
        {"percentage": 25, "duration": "30 minutes", "rollback_if": "error_rate > 0.5%"},
        {"percentage": 100, "duration": "N/A"}
      ],
      "monitoring": "Real-time dashboards comparing canary vs baseline metrics",
      "auto_rollback": true
    },
    "feature_flags": {
      "enabled": false,
      "tool": "LaunchDarkly | Unleash | AWS AppConfig",
      "use_cases": [
        "Gradual feature rollout (10% users, then 50%, then 100%)",
        "A/B testing (50% see new UI, 50% see old UI)",
        "Emergency kill switch (disable feature instantly without deployment)"
      ]
    },
    "backup_and_disaster_recovery": {
      "backup_frequency": "Daily automated backups at 2 AM UTC",
      "backup_retention": "30 days",
      "backup_storage": "S3 with cross-region replication to disaster recovery region",
      "restore_testing": {
        "frequency": "Monthly",
        "procedure": "Restore staging from production backup, validate data integrity",
        "success_criteria": "Restore completes in < 1 hour, data matches production"
      },
      "disaster_recovery_drill": {
        "frequency": "Quarterly",
        "scenario": "Primary region unavailable, failover to DR region",
        "steps": [
          "Update DNS to point to DR region",
          "Promote read replica to master in DR region",
          "Deploy services to DR region",
          "Validate system functional in DR region"
        ],
        "success_criteria": "Failover completes within RTO (e.g., 4 hours), data loss within RPO (e.g., 15 minutes)"
      }
    },
    "rollback_strategy": {
      "automated_rollback": {
        "enabled": true,
        "triggers": [
          "Error rate > 5% for 5 minutes",
          "Health check failures > 50% of instances",
          "p95 latency > 2x baseline for 10 minutes"
        ],
        "rollback_method": "Ansible playbook: ansible/playbooks/rollback.yml --limit prod",
        "rollback_time_target": "< 5 minutes"
      },
      "manual_rollback": {
        "procedure": "Documented in runbooks/rollback.md",
        "steps": [
          "Identify previous stable version from deployment log",
          "Run rollback playbook or redeploy previous Docker image tag",
          "Verify health checks pass, error rate returns to normal",
          "Post-mortem: Document why rollback was needed"
        ],
        "practice_frequency": "Monthly rollback drill in staging"
      }
    }
  },
  "INSTRUCTIONS": {
    "when_to_use": "Use this template for ANY UAF/IT system that will be deployed to production. Complete this DURING systems engineering phase (SE-02), not during testing phase.",
    "upfront_principle": "Operational environment is NOT an afterthought. Real operational conditions (failures, attacks, load) are designed for NOW. Testing phase executes the tests defined here.",
    "required_sections": [
      "operational_environment_conditions (define real-world failures system will face)",
      "service_decomposition_boundaries (DDD, bounded contexts, data ownership)",
      "containerization_packaging (Docker, orchestration choice)",
      "infrastructure_as_code_automation (Ansible for deployment automation)",
      "ci_cd_pipeline_integration (automated testing, deployment strategies)",
      "scalability_resilience (horizontal scaling, circuit breakers, fault tolerance)",
      "security_compliance (IAM, secrets, network security, encryption)",
      "monitoring_logging_observability (metrics, logs, alerts, dashboards)",
      "testing_rollback_strategies (define which tests to run, rollback procedures)"
    ],
    "optional_sections": [
      "service_discovery_networking (if microservices with dynamic IPs)",
      "cost_management_optimization (important but not blocking)"
    ],
    "integration_with_architecture": "Create operational_environment.json in specs/machine/ directory alongside service architectures",
    "validation_requirement": "Operational environment must be reviewed and validated before SE-03 gate",
    "testing_phase_relationship": "Testing phase (workflow 04) EXECUTES tests defined here. It does NOT define new tests - those decisions are architectural and made NOW.",
    "framework_conditional": "Only required for UAF framework. Non-IT frameworks (biology, ecology) don't have operational deployment concerns."
  }
}
