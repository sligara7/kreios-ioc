{
  "template_version": "1.0",
  "template_description": "Deployment architecture requirements for IT systems emphasizing ease, simplicity, and straightforward deployment. REQUIRED for UAF systems.",
  "applicability": {
    "framework": "uaf",
    "system_type": "IT systems requiring deployment infrastructure",
    "mandatory_when": "Production deployment of any IT system",
    "optional_when": "Research prototypes or proof-of-concepts"
  },
  "deployment_philosophy": {
    "primary_goals": [
      "REQUIRED: one_command_deployment | reproducible_builds | self_contained | automated_rollback | zero_downtime"
    ],
    "simplicity_targets": [
      "REQUIRED: developer_friendly | ops_friendly | minimal_dependencies | clear_documentation"
    ],
    "target_environments": [
      "REQUIRED: local_development | staging | production | disaster_recovery"
    ],
    "deployment_time_target": "REQUIRED: Duration to deploy from scratch (e.g., 5 minutes, 30 minutes)",
    "rollback_time_target": "REQUIRED: Duration to rollback failed deployment (e.g., 1 minute, 5 minutes)"
  },
  "containerization": {
    "strategy": "REQUIRED: docker | podman | none",
    "container_registry": "REQUIRED: dockerhub | ecr | gcr | ghcr | self_hosted",
    "base_images": [
      {
        "service": "EXAMPLE: api_service",
        "base_image": "python:3.11-slim",
        "rationale": "Minimal attack surface, official Python image"
      }
    ],
    "dockerfile_standards": {
      "multi_stage_builds": true,
      "layer_optimization": true,
      "secrets_in_build": false,
      "rootless_containers": true,
      "health_check_included": true
    },
    "image_scanning": {
      "enabled": true,
      "tools": ["REQUIRED: trivy | snyk | clair | grype"],
      "scan_frequency": "REQUIRED: on_build | daily | weekly",
      "block_on_critical": true
    },
    "image_versioning": {
      "strategy": "REQUIRED: semantic_versioning | commit_sha | timestamp | git_tag",
      "latest_tag_policy": "REQUIRED: rolling | immutable | discouraged",
      "retention_policy": "REQUIRED: Keep last N versions or X days"
    },
    "implementation_notes": "Describe Dockerfile best practices, build optimization, and security hardening"
  },
  "orchestration": {
    "strategy": "REQUIRED: docker_compose | kubernetes | docker_swarm | nomad | bare_metal",
    "chosen_rationale": "REQUIRED: Explain why this orchestration strategy was chosen (complexity vs features)",
    "docker_compose": {
      "applicable": true,
      "compose_file_version": "3.8",
      "services_definition": "REQUIRED: Path to docker-compose.yml",
      "environment_files": [
        ".env.development",
        ".env.staging",
        ".env.production"
      ],
      "volume_management": {
        "persistent_volumes": [
          {
            "name": "EXAMPLE: database_data",
            "mount_path": "/var/lib/postgresql/data",
            "backup_strategy": "daily snapshots"
          }
        ],
        "bind_mounts": [
          "OPTIONAL: For development only"
        ]
      },
      "networking": {
        "default_network": "bridge",
        "custom_networks": [
          {
            "name": "EXAMPLE: backend_network",
            "purpose": "Internal service communication",
            "driver": "bridge"
          }
        ],
        "external_access": "REQUIRED: via API gateway only"
      },
      "deployment_command": "REQUIRED: docker-compose up -d (single command to deploy entire system)",
      "implementation_notes": "Describe service dependencies, startup order, and health check strategy"
    },
    "kubernetes": {
      "applicable": false,
      "cluster_type": "OPTIONAL: eks | gke | aks | self_hosted | k3s | minikube",
      "namespace_strategy": "OPTIONAL: per_environment | per_team | per_application",
      "helm_charts": {
        "enabled": false,
        "chart_repository": "OPTIONAL: artifacthub | custom",
        "values_files": [
          "values.yaml",
          "values-prod.yaml"
        ]
      },
      "manifests": {
        "deployments": "REQUIRED: Path to deployment manifests",
        "services": "REQUIRED: Path to service manifests",
        "ingress": "REQUIRED: Path to ingress manifests",
        "configmaps": "OPTIONAL: Path to configmap manifests",
        "secrets": "REQUIRED: Path to sealed secrets or external secrets"
      },
      "resource_limits": {
        "cpu_requests": "REQUIRED: Define per service",
        "cpu_limits": "REQUIRED: Define per service",
        "memory_requests": "REQUIRED: Define per service",
        "memory_limits": "REQUIRED: Define per service"
      },
      "autoscaling": {
        "horizontal_pod_autoscaler": {
          "enabled": false,
          "min_replicas": 2,
          "max_replicas": 10,
          "target_cpu_utilization": 70,
          "target_memory_utilization": 80
        },
        "vertical_pod_autoscaler": {
          "enabled": false
        }
      },
      "implementation_notes": "Describe cluster setup, kubectl commands, and deployment automation"
    }
  },
  "infrastructure_as_code": {
    "enabled": true,
    "tool": "REQUIRED: terraform | cloudformation | pulumi | ansible | none",
    "infrastructure_definition": "REQUIRED: Path to IaC files",
    "managed_resources": [
      "EXAMPLE: vpc | subnets | security_groups | load_balancers | databases | dns_records"
    ],
    "state_management": {
      "backend": "REQUIRED: s3 | gcs | azure_blob | terraform_cloud | local (NOT RECOMMENDED for production)",
      "state_locking": true,
      "encryption_enabled": true
    },
    "deployment_workflow": {
      "plan_command": "REQUIRED: terraform plan",
      "apply_command": "REQUIRED: terraform apply -auto-approve (in CI/CD only)",
      "destroy_command": "REQUIRED: terraform destroy (manual approval required)",
      "drift_detection": "REQUIRED: Describe how infrastructure drift is detected and resolved"
    },
    "implementation_notes": "Describe module organization, variable management, and CI/CD integration"
  },
  "ci_cd_pipeline": {
    "enabled": true,
    "platform": "REQUIRED: github_actions | gitlab_ci | jenkins | circleci | travis_ci | bitbucket_pipelines",
    "pipeline_definition": "REQUIRED: Path to pipeline configuration (.github/workflows, .gitlab-ci.yml, Jenkinsfile)",
    "stages": [
      {
        "stage_name": "EXAMPLE: build",
        "description": "Compile code, run unit tests, build Docker images",
        "duration_target": "3 minutes",
        "failure_action": "block_deployment"
      },
      {
        "stage_name": "EXAMPLE: test",
        "description": "Integration tests, security scans, code quality checks",
        "duration_target": "5 minutes",
        "failure_action": "block_deployment"
      },
      {
        "stage_name": "EXAMPLE: deploy_staging",
        "description": "Deploy to staging environment for validation",
        "duration_target": "5 minutes",
        "failure_action": "block_production_deployment"
      },
      {
        "stage_name": "EXAMPLE: deploy_production",
        "description": "Deploy to production with gradual rollout",
        "duration_target": "10 minutes",
        "failure_action": "auto_rollback",
        "approval_required": true
      }
    ],
    "automated_testing": {
      "unit_tests": {
        "enabled": true,
        "coverage_threshold": 80,
        "block_on_failure": true
      },
      "integration_tests": {
        "enabled": true,
        "test_environment": "docker_compose",
        "block_on_failure": true
      },
      "security_tests": {
        "sast_enabled": true,
        "dependency_scanning_enabled": true,
        "container_scanning_enabled": true,
        "block_on_critical": true
      },
      "performance_tests": {
        "enabled": false,
        "load_test_tool": "OPTIONAL: k6 | jmeter | locust",
        "threshold_p95_latency": "OPTIONAL: 200ms",
        "threshold_error_rate": "OPTIONAL: 1%"
      }
    },
    "deployment_strategy": {
      "strategy_type": "REQUIRED: rolling_update | blue_green | canary | recreate",
      "rollback_on_failure": true,
      "rollback_trigger": [
        "EXAMPLE: health_check_failure",
        "EXAMPLE: error_rate_spike",
        "EXAMPLE: manual_trigger"
      ],
      "gradual_rollout": {
        "enabled": false,
        "stages": [
          {"percentage": 10, "duration": "5 minutes"},
          {"percentage": 50, "duration": "15 minutes"},
          {"percentage": 100, "duration": "N/A"}
        ]
      }
    },
    "secrets_injection": {
      "method": "REQUIRED: environment_variables | secrets_manager | vault | kubernetes_secrets",
      "secrets_source": "REQUIRED: aws_secrets_manager | azure_key_vault | hashicorp_vault | github_secrets",
      "rotation_handled": true
    },
    "implementation_notes": "Describe pipeline triggers, branch strategies, and notification channels"
  },
  "environment_management": {
    "environments": [
      {
        "name": "development",
        "purpose": "Local development and feature testing",
        "deployment_method": "docker-compose",
        "infrastructure": "local",
        "data_strategy": "synthetic_data | anonymized_production_data | minimal_seed_data",
        "automatic_deployment": true
      },
      {
        "name": "staging",
        "purpose": "Pre-production validation and integration testing",
        "deployment_method": "docker-compose | kubernetes",
        "infrastructure": "cloud_staging",
        "data_strategy": "anonymized_production_data | synthetic_data",
        "automatic_deployment": true
      },
      {
        "name": "production",
        "purpose": "Live user-facing environment",
        "deployment_method": "kubernetes | docker-compose",
        "infrastructure": "cloud_production",
        "data_strategy": "live_data",
        "automatic_deployment": false,
        "approval_required": true,
        "deployment_window": "OPTIONAL: Define maintenance windows or always-allowed"
      }
    ],
    "environment_parity": {
      "configuration_parity": "REQUIRED: Describe how dev/staging/prod configs differ (only secrets and scale)",
      "infrastructure_parity": "REQUIRED: Describe infrastructure differences across environments",
      "data_parity": "REQUIRED: Describe data strategies for non-production environments"
    },
    "promotion_strategy": "REQUIRED: dev -> staging -> production | feature_branches -> main -> production",
    "implementation_notes": "Describe environment provisioning, teardown, and refresh procedures"
  },
  "configuration_management": {
    "strategy": "REQUIRED: environment_variables | config_files | remote_config | feature_flags",
    "config_storage": "REQUIRED: git_repository | aws_parameter_store | consul | etcd | kubernetes_configmaps",
    "config_organization": {
      "per_service": true,
      "per_environment": true,
      "shared_config": [
        "EXAMPLE: database_url | redis_url | logging_level"
      ]
    },
    "config_validation": {
      "enabled": true,
      "validation_method": "REQUIRED: json_schema | pydantic | custom",
      "fail_on_invalid": true
    },
    "config_reloading": {
      "hot_reload_supported": false,
      "reload_method": "REQUIRED: restart_service | SIGHUP | inotify | polling"
    },
    "implementation_notes": "Describe config injection, precedence order, and sensitive data handling"
  },
  "service_discovery": {
    "enabled": true,
    "mechanism": "REQUIRED: dns | consul | etcd | kubernetes_service | docker_compose_service_name | hardcoded",
    "service_registry": "REQUIRED: Describe how services find each other",
    "health_checks": {
      "enabled": true,
      "health_check_endpoints": [
        {
          "service": "EXAMPLE: api_service",
          "endpoint": "/health",
          "expected_status": 200,
          "timeout": "5 seconds",
          "interval": "10 seconds"
        }
      ],
      "readiness_probes": {
        "enabled": true,
        "probe_endpoint": "REQUIRED: /ready | /healthz",
        "checks": [
          "EXAMPLE: database_connection",
          "EXAMPLE: dependent_service_availability",
          "EXAMPLE: cache_connection"
        ]
      },
      "liveness_probes": {
        "enabled": true,
        "probe_endpoint": "REQUIRED: /health | /ping",
        "failure_threshold": 3,
        "restart_on_failure": true
      }
    },
    "implementation_notes": "Describe service registration, deregistration, and failure handling"
  },
  "database_deployment": {
    "database_type": "REQUIRED: postgresql | mysql | mongodb | redis | none",
    "deployment_method": "REQUIRED: managed_service | self_hosted_container | self_hosted_vm",
    "managed_service": {
      "applicable": false,
      "provider": "OPTIONAL: aws_rds | azure_database | google_cloud_sql",
      "version": "REQUIRED: Database version",
      "instance_size": "OPTIONAL: Define compute and storage",
      "multi_az": false,
      "automated_backups": true,
      "backup_retention": "7 days"
    },
    "self_hosted": {
      "applicable": true,
      "container_image": "REQUIRED: postgres:15-alpine",
      "data_persistence": {
        "volume_type": "REQUIRED: docker_volume | host_mount | cloud_block_storage",
        "volume_size": "REQUIRED: 20GB",
        "backup_strategy": "REQUIRED: Describe backup approach"
      },
      "replication": {
        "enabled": false,
        "replication_type": "OPTIONAL: master_slave | master_master | multi_master",
        "replica_count": 2
      }
    },
    "migration_management": {
      "tool": "REQUIRED: alembic | flyway | liquibase | django_migrations | rails_migrations | custom_scripts",
      "migration_location": "REQUIRED: Path to migration files",
      "migration_strategy": {
        "when": "REQUIRED: before_deployment | after_deployment | manual",
        "rollback_supported": true,
        "automated": true
      }
    },
    "connection_pooling": {
      "enabled": true,
      "pool_size": 20,
      "max_overflow": 10,
      "pool_timeout": "30 seconds"
    },
    "implementation_notes": "Describe database initialization, seeding, and disaster recovery"
  },
  "monitoring_observability": {
    "metrics": {
      "enabled": true,
      "metrics_format": "REQUIRED: prometheus | statsd | cloudwatch | datadog",
      "metrics_endpoint": "/metrics",
      "key_metrics": [
        "EXAMPLE: request_count",
        "EXAMPLE: request_duration",
        "EXAMPLE: error_rate",
        "EXAMPLE: active_connections",
        "EXAMPLE: queue_depth"
      ],
      "scrape_interval": "15 seconds",
      "retention_period": "15 days"
    },
    "logging": {
      "enabled": true,
      "log_format": "REQUIRED: json | plaintext",
      "log_level": "REQUIRED: debug | info | warning | error",
      "log_aggregation": {
        "tool": "REQUIRED: elasticsearch | cloudwatch | datadog | splunk | loki",
        "retention_period": "30 days"
      },
      "structured_logging": true,
      "correlation_ids": true
    },
    "tracing": {
      "enabled": false,
      "tracing_tool": "OPTIONAL: jaeger | zipkin | aws_xray | datadog_apm",
      "sampling_rate": 0.1,
      "trace_all_requests": false
    },
    "alerting": {
      "enabled": true,
      "alerting_tool": "REQUIRED: prometheus_alertmanager | cloudwatch_alarms | pagerduty | opsgenie",
      "critical_alerts": [
        {
          "alert_name": "EXAMPLE: HighErrorRate",
          "condition": "error_rate > 5% for 5 minutes",
          "severity": "critical",
          "notification": "pagerduty | email | slack"
        },
        {
          "alert_name": "EXAMPLE: ServiceDown",
          "condition": "health_check_failure for 2 minutes",
          "severity": "critical",
          "notification": "pagerduty | email | slack"
        }
      ],
      "warning_alerts": [
        {
          "alert_name": "EXAMPLE: HighLatency",
          "condition": "p95_latency > 500ms for 10 minutes",
          "severity": "warning",
          "notification": "slack | email"
        }
      ]
    },
    "dashboards": {
      "enabled": true,
      "dashboard_tool": "REQUIRED: grafana | cloudwatch | datadog | kibana",
      "key_dashboards": [
        "EXAMPLE: System Overview",
        "EXAMPLE: Service Health",
        "EXAMPLE: Database Performance",
        "EXAMPLE: API Gateway Metrics"
      ]
    },
    "implementation_notes": "Describe observability stack deployment, dashboard templates, and runbooks"
  },
  "backup_disaster_recovery": {
    "backup_strategy": {
      "enabled": true,
      "backup_frequency": "REQUIRED: hourly | daily | weekly",
      "backup_retention": "REQUIRED: 30 days | 90 days | 1 year",
      "backup_storage": "REQUIRED: s3 | gcs | azure_blob | local (NOT RECOMMENDED)",
      "backup_encryption": true,
      "automated_backups": true
    },
    "backup_types": [
      {
        "data_type": "EXAMPLE: database",
        "backup_method": "pg_dump | mysqldump | mongodump",
        "frequency": "daily at 2 AM UTC",
        "retention": "30 days"
      },
      {
        "data_type": "EXAMPLE: application_state",
        "backup_method": "volume_snapshot",
        "frequency": "daily",
        "retention": "7 days"
      }
    ],
    "restore_testing": {
      "enabled": true,
      "test_frequency": "REQUIRED: monthly | quarterly | annually",
      "last_test_date": "YYYY-MM-DD",
      "restore_time_target": "REQUIRED: Duration to fully restore (e.g., 1 hour, 4 hours)"
    },
    "disaster_recovery": {
      "rpo_target": "REQUIRED: Recovery Point Objective (e.g., 1 hour data loss maximum)",
      "rto_target": "REQUIRED: Recovery Time Objective (e.g., 4 hours to restore service)",
      "dr_region": "OPTIONAL: Secondary region for disaster recovery",
      "failover_strategy": "REQUIRED: manual | automatic | none",
      "dr_testing_frequency": "REQUIRED: quarterly | annually"
    },
    "implementation_notes": "Describe backup automation, restoration procedures, and DR runbooks"
  },
  "scaling_strategy": {
    "horizontal_scaling": {
      "supported": true,
      "stateless_services": [
        "EXAMPLE: api_service | web_service"
      ],
      "scaling_triggers": [
        "EXAMPLE: cpu_utilization > 70%",
        "EXAMPLE: request_queue_depth > 100"
      ],
      "min_instances": 2,
      "max_instances": 10
    },
    "vertical_scaling": {
      "supported": true,
      "resize_strategy": "REQUIRED: manual | automated | none",
      "downtime_required": true
    },
    "load_balancing": {
      "enabled": true,
      "load_balancer_type": "REQUIRED: nginx | haproxy | alb | elb | gcp_load_balancer",
      "algorithm": "REQUIRED: round_robin | least_connections | ip_hash",
      "health_checks": true,
      "session_affinity": false
    },
    "implementation_notes": "Describe scaling procedures, load testing, and capacity planning"
  },
  "deployment_documentation": {
    "quick_start_guide": {
      "exists": true,
      "location": "REQUIRED: README.md | docs/deployment/quick-start.md",
      "time_to_deploy": "REQUIRED: 5 minutes | 30 minutes (from guide to running system)"
    },
    "deployment_runbooks": [
      {
        "runbook_name": "EXAMPLE: Initial Deployment",
        "location": "REQUIRED: Path to runbook",
        "target_audience": "developers | ops | both"
      },
      {
        "runbook_name": "EXAMPLE: Rolling Update",
        "location": "REQUIRED: Path to runbook",
        "target_audience": "ops"
      },
      {
        "runbook_name": "EXAMPLE: Emergency Rollback",
        "location": "REQUIRED: Path to runbook",
        "target_audience": "ops"
      }
    ],
    "troubleshooting_guide": {
      "exists": true,
      "location": "REQUIRED: docs/troubleshooting.md",
      "common_issues": [
        "EXAMPLE: Port conflicts",
        "EXAMPLE: Database connection failures",
        "EXAMPLE: Out of memory errors"
      ]
    },
    "implementation_notes": "Ensure documentation is beginner-friendly with step-by-step instructions and screenshots"
  },
  "INSTRUCTIONS": {
    "when_to_use": "Use this template for ANY UAF system requiring production deployment",
    "required_sections": [
      "deployment_philosophy",
      "containerization",
      "orchestration (choose docker_compose OR kubernetes, not both for simplicity)",
      "ci_cd_pipeline",
      "environment_management",
      "service_discovery",
      "monitoring_observability",
      "deployment_documentation"
    ],
    "recommended_sections": [
      "infrastructure_as_code (for cloud deployments)",
      "database_deployment (if using databases)",
      "backup_disaster_recovery (for production systems)",
      "scaling_strategy (for expected growth)"
    ],
    "simplicity_first": "Default to Docker Compose unless Kubernetes features are absolutely necessary. Prioritize ease of use over advanced features.",
    "one_command_deployment": "System MUST be deployable with a single command (e.g., 'docker-compose up -d' or 'kubectl apply -f manifests/')",
    "integration_with_architecture": "Create deployment_architecture.json in specs/machine/ directory alongside service architectures",
    "validation_requirement": "Deployment architecture must be tested and validated before production release",
    "framework_conditional": "Only required for UAF framework with deployment_characteristics.port_management_applicable == true"
  }
}
